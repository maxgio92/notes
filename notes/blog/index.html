<!doctype html><html lang=en-us xmlns=http://www.w3.org/1999/xhtml><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon href="data:;base64,iVBORw0KGgo="><title>maxgio's notes | Blogging</title><style type=text/css>body{font-size:150%;font-family:muli,avenir,helvetica neue,helvetica,ubuntu,roboto,noto,segoe ui,arial,sans-serif}</style></head><body><h1>Blogging</h1><h2 id=co-re>CO-RE</h2><h3 id=features>Features</h3><h4 id=dev-time>Dev time</h4><p>From “recap” paragraph of <a href=https://nakryiko.com/posts/bpf-portability-and-co-re/#bpf-state-of-the-art>https://nakryiko.com/posts/bpf-portability-and-co-re/#bpf-state-of-the-art</a></p><ul><li><p>vmlinux.h eliminates dependency on kernel headers;</p></li><li><p>field relocations (field offsets, existence, size, etc) make data extraction from kernel portable;</p></li><li><p>libbpf-provided Kconfig extern variables allow BPF programs to accommodate various kernel version- and configuration-specific changes;</p></li><li><p>when everything else fails, app-provided read-only configuration and struct flavors are an ultimate big hammer to address whatever complicated scenario application has to handle.</p></li></ul><p><a id=nav-menu><strong>Menu</strong></a></p><ul><li><a href=/notes/>Notes</a></li></ul><p><a href=#>Back to top</a></p></body></html>