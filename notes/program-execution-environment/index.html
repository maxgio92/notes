<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>The program execution environment - maxgio's notes</title><meta name=description content="We know that the programs are executed by the CPU and that the program&rsquo;s binary instructions are stored in a volatile memory that is the random access memory.
The scope of this blog is to dig into how the CPU keeps track of and executes instructions as expected by the program. As RAM locations are byte-addressable the CPU needs a way to keep track of the addresses in order to retrieve the data from it, which is in our case CPU instructions that are then executed."><meta name=author content><link rel="preload stylesheet" as=style href=https://notes.maxgio.me/app.min.css><link rel="preload stylesheet" as=style href=https://notes.maxgio.me/an-old-hope.min.css><script defer src=https://notes.maxgio.me/highlight.min.js onload=hljs.initHighlightingOnLoad();></script><link rel=preload as=image href=https://notes.maxgio.me/theme.png><link rel=icon href=https://notes.maxgio.me/favicon.ico><link rel=apple-touch-icon href=https://notes.maxgio.me/apple-touch-icon.png><meta name=generator content="Hugo 0.79.1"><meta property="og:title" content="The program execution environment"><meta property="og:description" content="We know that the programs are executed by the CPU and that the program&rsquo;s binary instructions are stored in a volatile memory that is the random access memory.
The scope of this blog is to dig into how the CPU keeps track of and executes instructions as expected by the program. As RAM locations are byte-addressable the CPU needs a way to keep track of the addresses in order to retrieve the data from it, which is in our case CPU instructions that are then executed."><meta property="og:type" content="article"><meta property="og:url" content="https://notes.maxgio.me/notes/program-execution-environment/"><meta itemprop=name content="The program execution environment"><meta itemprop=description content="We know that the programs are executed by the CPU and that the program&rsquo;s binary instructions are stored in a volatile memory that is the random access memory.
The scope of this blog is to dig into how the CPU keeps track of and executes instructions as expected by the program. As RAM locations are byte-addressable the CPU needs a way to keep track of the addresses in order to retrieve the data from it, which is in our case CPU instructions that are then executed."><meta itemprop=wordCount content="1885"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="The program execution environment"><meta name=twitter:description content="We know that the programs are executed by the CPU and that the program&rsquo;s binary instructions are stored in a volatile memory that is the random access memory.
The scope of this blog is to dig into how the CPU keeps track of and executes instructions as expected by the program. As RAM locations are byte-addressable the CPU needs a way to keep track of the addresses in order to retrieve the data from it, which is in our case CPU instructions that are then executed."></head><body class=not-ready data-menu=false><header class=header><p class=logo><a class=site-name href=https://notes.maxgio.me/>maxgio's notes</a><a class=btn-dark></a></p><script>let bodyClx=document.body.classList;let btnDark=document.querySelector('.btn-dark');let sysDark=window.matchMedia('(prefers-color-scheme: dark)');let darkVal=localStorage.getItem('dark');let setDark=(isDark)=>{bodyClx[isDark?'add':'remove']('dark');localStorage.setItem('dark',isDark?'yes':'no');};setDark(darkVal?darkVal==='yes':sysDark.matches);requestAnimationFrame(()=>bodyClx.remove('not-ready'));btnDark.addEventListener('click',()=>setDark(!bodyClx.contains('dark')));sysDark.addEventListener('change',(event)=>setDark(event.matches));</script></header><main class=main><article class=post-single><header class=post-title><p></p><h1>The program execution environment</h1></header><section class=post-content><p>We know that the programs are executed by the CPU and that the program&rsquo;s binary instructions are stored in a volatile memory that is the random access memory.</p><p>The scope of this blog is to dig into how the CPU keeps track of and executes instructions as expected by the program.
As RAM locations are byte-addressable the CPU needs a way to keep track of the addresses in order to retrieve the data from it, which is in our case CPU instructions that are then executed.</p><p>The CPU uses small built-in memory areas called register to hold data retrieved from main memory. Registers come in two types: general-purpose and special-purpose. Special-purpose registers include pointer registers, which are designed specifically to store pointers, which means, they store the memory address&rsquo;s value.</p><p>There are other types of registers but they&rsquo;re out of scope for this walkthrough.</p><p>The first part will go through the main pointer registers, which are commonly implemented by the predominant architectures (x86, ARM, MIPS, PowerPC as far as I know).
So, please consider that these specifics may differ depending on the architecture.</p><h2 id=the-program-counter-pc-the-stack-pointer-sp-and-the-base-pointer-bp-processor-registers>The program counter (PC), the stack pointer (SP), and the base pointer (BP) processor registers</h2><p>The program counter (PC), often also called instruction pointer (IP) in x86 architectures, is a register that points to code, that is, the instruction that will be executed next. The instruction data will be fetched, will be stored in the instruction register (IR), and executed during the instruction cycle.
Depending on the instruction set, the IP will be increased instruction by instruction by the instruction size (e.g. 8 bytes on 64 but Instruction Set Architectures).</p><p>When compiling a program it will contain the instructions to be executed, that the CPU will fetch and execute, and how they&rsquo;re stored depends on the executable format. For example, considering the ELF format, the code is represented by the <code>.text</code> section.</p><p><img src=https://raw.githubusercontent.com/maxgio92/notes/14bdde325f646b53ee0b6501f0ba9d3ecbaded4f/content/notes/memory-cpu-program-counter.gif alt=memory-program-counter-1>
<img src=https://raw.githubusercontent.com/maxgio92/notes/14bdde325f646b53ee0b6501f0ba9d3ecbaded4f/content/notes/memory-cpu-program-counter-1.gif alt=memory-program-counter-2></p><p>On the other side, the stack pointer (SP) and base pointer (BP) point to the stack, which contains data about the program being executed.</p><p>While a detailed explanation of the stack is beyond the scope of this blog, here&rsquo;s a basic idea: it&rsquo;s a special area of memory that the CPU uses to manage data related to the program&rsquo;s functions (subroutines) as they are called and executed, pushing it to it in a LIFO method. We&rsquo;ll see later on in more detail.</p><p>Data and code are organized in the process&rsquo;s address space with areas. Explaining how the OS manages access to memory with virtual and physical addressing or processor rings, is out of the scope.</p><p>As the stack grows whenever the CPU adds new data while executing the program, the stack pointer is at the lowest position in the stack.</p><blockquote><p>Remember: the stack grows from the highest address to the lowest address
So, when a new variable of 4 bytes is declared, the stack pointer will be increased by 4 bytes too.</p></blockquote><p>In the following image you can find an example considering a single process:</p><p><img src=https://raw.githubusercontent.com/maxgio92/notes/3db4d57bd2a84df56925e19ab24b03badfd649f1/content/notes/memory-process-data-code.png alt=memory-program-counter-2></p><p>Specifically, a stack pointer (SP) points to the first free and unused address on the stack.
It can reserve more space on the stack by adjusting the stack pointer, and then <code>PUSH</code> instruction (valid in many architectures) pushes data at the address pointed to by the stack pointer (e.g. local variables).</p><p>Meanwhile, usually, the base pointer (BP) is a snapshot of the stack pointer (SP) at the start of the frame, so that function parameters and local variables are accessed by adding and subtracting, respectively, a constant offset from it.</p><p>You can find a diagram in the picture below:</p><p><img src=https://raw.githubusercontent.com/maxgio92/notes/14bdde325f646b53ee0b6501f0ba9d3ecbaded4f/content/notes/memory-stack-frames-simple.png alt=stack-frame></p><p>In the previous image, the base pointer is referred to as the frame pointer (FP). What is fundamental here is the main stack structure is organized in sub-structures named frames. We&rsquo;ll go through it while explaining how the function call path works.</p><h3 id=the-call-path>The call path</h3><p>When a new function is called a dedicated memory space dedicated to the new function is pushed to the stack. This memory space will contain function specific data like arguments, local variables, saved registers if needed.
Also, the previous base pointer is also pushed to the stack.</p><p>While this is usually true, it&rsquo;s not mandatory and it depends on how the binary has been compiled. This mainly depends on the compiler optimization techniques.</p><blockquote><p>If you&rsquo;re interested on the main impacts of libraries compiled with this optimization and distributed by common Linux distributions I recommend this Brendan Gregg&rsquo;s great article: <a href=https://www.brendangregg.com/blog/2024-03-17/the-return-of-the-frame-pointers.html>https://www.brendangregg.com/blog/2024-03-17/the-return-of-the-frame-pointers.html</a>.</p></blockquote><blockquote><p><strong>The saved base pointers and the stack unwinding</strong></p><p>When the base pointer is pushed to the stack, it points to the previous frame&rsquo;s base pointer, enabling debuggers or profilers to walk the stack, also called stack unwinding. But FPO or frame pointer omission optimization will actually eliminate this and use the base pointer as another register and access locals directly off of the stack pointer. In this case, the stack unwinding is a bit more difficult since it can no longer directly access the stack frames of earlier function calls.</p></blockquote><p>In particular, CALL instruction pushes also the value of the program counter at the moment of the new function call (next instruction address), and gives control to the target address. The program counter is set to the target address of the <code>CALL</code> instruction, which is, the first instruction of the called function.</p><p>In a nutshell: the just pushed return address is a snapshot of the program counter, and the pushed frame pointer is a snapshot of the base pointer, and they&rsquo;re both available in the stack.</p><p>As a result, control is passed to the called subroutine address and the return address, that is the address of the instruction next to <code>CALL</code>, is available.</p><h3 id=the-return-path>The return path</h3><p>On the return path from the function, <code>RET</code> instruction <code>POP</code>s the return address from the stack and puts it in the program counter register. So, the next instruction is available from that return address.</p><p>Since the program counter register holds the address of the next instruction to be executed, loading the return address into PC effectively points the program execution to the instruction that follows the function call. This ensures the program resumes execution from the correct location after the function is completed.</p><p><img src=https://raw.githubusercontent.com/maxgio92/notes/14bdde325f646b53ee0b6501f0ba9d3ecbaded4f/content/notes/memory-stack-frames.png alt=stack-frames></p><p>In the case of a function calling a function, the program counter returns to the return address in the previous stack frame and starts executing from there.</p><p>Because all of the above points need to be memorized on the stack, the stack size will naturally increase, and on return decrease. And of course, the same happens to the stack and base pointers.</p><h3 id=the-data-the-code-and-the-heap-areas>The data, the code and the heap areas</h3><p>When a program is loaded into memory, the operating system statically allocates a specific amount of memory for it. This includes space for the program&rsquo;s instructions and the stack.</p><p>I know this is too simplified, but we&rsquo;ll talk about how the program is loaded and organized in memory later on.</p><p>On dynamic allocations requested by the program, the heap acquires memory from the bottom of the same region and grows upwards towards the middle of the same memory region. While explaining how dynamic memory mapping implementations work in operating systems is out of scope here, but it&rsquo;s important to say that user processes see one contigous memory space thanks to the virtual memory mapping managed by the OS.</p><p>Below is an example of the memory regions and mapping of data and code, particularly with the ELF executable format:</p><p><img src=https://raw.githubusercontent.com/maxgio92/notes/68c5220995702493845a3d96cc9d6dc7ce61ec8f/content/notes/memory-regions-allocations.jpg alt=memory-regions-stack-instructions></p><h2 id=what-about-the-frame-pointer>What about the frame pointer?</h2><p>The frame pointer is the base pointer because is set up when a function is called to establish a fixed reference (base) point for accessing local variables and parameters within the function&rsquo;s stack frame. Depending on what ABI you use, parameters are passed either on the stack or via registers. For instance, on i386 System V ABI, parameter 0 is at the base pointer + 8 (i.e. &ldquo;8(%ebp)"). In the x86-64 ABI, parameter 0 is stored in the %rdi register.</p><p>Below the parameters on the stack (remember, the stack grows down) are:</p><ul><li>the return address</li><li>the previous frame pointer</li><li>saved register state</li><li>the local variables of the function.</li></ul><p>Remember: the return address is a snapshot of the program counter, so it points to instructions (code).
The previous frame pointer is a snapshot of the base pointer, so it points to the stack (data).</p><p><img src=https://raw.githubusercontent.com/maxgio92/notes/5ab379b18942d782ac152cc81ad9029ae15d8dd1/content/notes/memory-stack-ip-bp.png alt=stack-return-address-previous-frame-pointer></p><p>Below the local variables are other stack frames resulting from more recent function calls, as well as generic stack space used for computation and temporary storage. The most recent of these is pointed to by the real stack pointer. This is the difference between the stack pointer and the frame/base pointer.</p><p>However, the frame pointer is not always required. Modern compilers can generate code that just uses the stack pointer. At any point in code generation, it can determine where the return address, parameters, and locals are relative to the stack pointer address (either by a constant offset or programmatically).</p><p>Without a frame pointer, though, it is much more difficult for debuggers to determine the stack backtrace. In particular, hardware debuggers that do not have symbolic program information are almost always unable to show the stack.</p><p>Why would you not use a frame pointer? In most architectures it frees up a register, essentially increasing the size of the CPU&rsquo;s fastest and best memory &ndash; its register file.</p><h3 id=clarification-about-the-register-names>Clarification about the register names</h3><p>On 16-bit ISA are usually called SP, BP, and IP.
Instead on 32-bit ESP, EBP, and EIP.
Finally, on 64-bit they&rsquo;re usually called RSP, RBP, and RIP.</p><h2 id=how-the-code-and-the-data-are-loaded-and-organized-in-the-allocated-memory>How the code and the data are loaded and organized in the allocated memory?</h2><blockquote><p>Note: the memory allocation during the fork is only mentioned here.</p></blockquote><p>On program execution (Unix-like fork and exec system call groups) OS allocates memory to later store the program&rsquo;s instructions (code) and data (in the stack).
On Unix-like operating systems, the exec family of system calls replaces the program executed by a process.
When a process calls exec, all instructions - in ELF executable format it&rsquo;s the text section - and the data in the process is replaced with the executable of the new program.
The OS then sets the PC to the memory address of the first instruction, which is fetched, decoded, and executed one by one.</p><blockquote><p>I couldn&rsquo;t find yet where the information about how to set up the stack at exec time from an ELF file are stored in the ELF structure.
Also, as a detail, although all data is replaced, all open file descriptors remain open after calling exec unless explicitly set to close-on-exec.</p></blockquote><p><img src=https://raw.githubusercontent.com/maxgio92/notes/d3bf6f231c330ba746354cc463469245fc9de7bc/content/notes/memory-map-exec.png alt=memory-map-exec></p><p>In particular, on Linux, on execs, the .text and .data ELF sections are loaded by the kernel at the base address.
The main stack is located just below and grows downwards.
Each thread and function call will have its own-stack / stack frame.
This is located below the main stack.
Each stack is separated by a guard page to detect Stack-Overflow.</p><p><img src=https://raw.githubusercontent.com/maxgio92/notes/d3bf6f231c330ba746354cc463469245fc9de7bc/content/notes/memory-map-elf.png alt=memory-map-elf></p><p>If you want to go deeper on the Linux <code>exec</code> path, I recommend <a href=https://github.com/0xAX/linux-insides/blob/f7c6b82a5c02309f066686dde697f4985645b3de/SysCall/linux-syscall-4.md#execve-system-call>this chapter</a> from the <a href=https://0xax.gitbooks.io/linux-insides/content/index.html>Linux insides</a> book.</p><h3 id=elf-structure>ELF structure</h3><p>Digging into the ELF format you can find below the structure of this executable and linkable format:</p><p><img src=https://raw.githubusercontent.com/maxgio92/notes/20f4417f50afb71a79a8712decea1f76ffc16cc9/content/notes/elf-dissection.avif alt=elf-structure></p><p>For more information please refer to the man of file formats and conventions for elf (<code>man 5 elf</code>).</p><h2 id=references>References</h2><ul><li><a href=https://www2.it.uu.se/edu/course/homepage/os/vt19/module-2/process-management/>https://www2.it.uu.se/edu/course/homepage/os/vt19/module-2/process-management/</a></li><li><a href=https://stackoverflow.com/questions/18278803/how-does-elf-file-format-defines-the-stack>https://stackoverflow.com/questions/18278803/how-does-elf-file-format-defines-the-stack</a></li><li><a href=https://stackoverflow.com/questions/21718397/what-are-the-esp-and-the-ebp-registers>https://stackoverflow.com/questions/21718397/what-are-the-esp-and-the-ebp-registers</a></li><li><a href=https://groups.google.com/g/golang-nuts/c/wtw0Swe0CAY>https://groups.google.com/g/golang-nuts/c/wtw0Swe0CAY</a></li><li><a href=https://www.polarsignals.com/blog/posts/2022/01/13/fantastic-symbols-and-where-to-find-them>https://www.polarsignals.com/blog/posts/2022/01/13/fantastic-symbols-and-where-to-find-them</a></li><li><a href=https://0xax.gitbooks.io/linux-insides/content/index.html>https://0xax.gitbooks.io/linux-insides/content/index.html</a></li></ul></section><nav class=post-nav><a class=prev href=https://notes.maxgio.me/notes/technicolor-timhub/><span>←</span><span>Technicolor router TIM-branded</span></a>
<a class=next href=https://notes.maxgio.me/notes/tmux/><span>TMux and stuff</span><span>→</span></a></nav></article></main><footer class=footer><p>&copy; 2024 <a href=https://notes.maxgio.me/>maxgio's notes</a></p><p>Powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>️</p><p><a href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>Paper 5.1</a></p></footer></body></html>