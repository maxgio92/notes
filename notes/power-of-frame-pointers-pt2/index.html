<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Unleashing the power of frame pointers for profiling pt.2 - Writing a simple profiler - maxgio's notes</title><meta name=description content="In the previous blog about the program execution environment, we introduced the concept of stack unwinding with frame pointers as one of the techniques leveraged for profiling a program.
In this blog, we&rsquo;ll see practically how we can build a simple sampling-based continuous profiler.
Because we don&rsquo;t require the application to be instrumented, we can use the Linux kernel instrumentation, and thanks to eBPF we&rsquo;re able to dynamically load and attach the profiler program to specific kernel entry points, limiting the overhead by exchanging data with userspace through eBPF maps."><meta name=author content><link rel="preload stylesheet" as=style href=https://notes.maxgio.me/app.min.css><link rel="preload stylesheet" as=style href=https://notes.maxgio.me/an-old-hope.min.css><script defer src=https://notes.maxgio.me/highlight.min.js onload=hljs.initHighlightingOnLoad();></script><link rel=preload as=image href=https://notes.maxgio.me/theme.png><link rel=icon href=https://notes.maxgio.me/favicon.ico><link rel=apple-touch-icon href=https://notes.maxgio.me/apple-touch-icon.png><meta name=generator content="Hugo 0.79.1"><meta property="og:title" content="Unleashing the power of frame pointers for profiling pt.2 - Writing a simple profiler"><meta property="og:description" content="In the previous blog about the program execution environment, we introduced the concept of stack unwinding with frame pointers as one of the techniques leveraged for profiling a program.
In this blog, we&rsquo;ll see practically how we can build a simple sampling-based continuous profiler.
Because we don&rsquo;t require the application to be instrumented, we can use the Linux kernel instrumentation, and thanks to eBPF we&rsquo;re able to dynamically load and attach the profiler program to specific kernel entry points, limiting the overhead by exchanging data with userspace through eBPF maps."><meta property="og:type" content="article"><meta property="og:url" content="https://notes.maxgio.me/notes/power-of-frame-pointers-pt2/"><meta itemprop=name content="Unleashing the power of frame pointers for profiling pt.2 - Writing a simple profiler"><meta itemprop=description content="In the previous blog about the program execution environment, we introduced the concept of stack unwinding with frame pointers as one of the techniques leveraged for profiling a program.
In this blog, we&rsquo;ll see practically how we can build a simple sampling-based continuous profiler.
Because we don&rsquo;t require the application to be instrumented, we can use the Linux kernel instrumentation, and thanks to eBPF we&rsquo;re able to dynamically load and attach the profiler program to specific kernel entry points, limiting the overhead by exchanging data with userspace through eBPF maps."><meta itemprop=wordCount content="1960"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Unleashing the power of frame pointers for profiling pt.2 - Writing a simple profiler"><meta name=twitter:description content="In the previous blog about the program execution environment, we introduced the concept of stack unwinding with frame pointers as one of the techniques leveraged for profiling a program.
In this blog, we&rsquo;ll see practically how we can build a simple sampling-based continuous profiler.
Because we don&rsquo;t require the application to be instrumented, we can use the Linux kernel instrumentation, and thanks to eBPF we&rsquo;re able to dynamically load and attach the profiler program to specific kernel entry points, limiting the overhead by exchanging data with userspace through eBPF maps."></head><body class=not-ready data-menu=false><header class=header><p class=logo><a class=site-name href=https://notes.maxgio.me/>maxgio's notes</a><a class=btn-dark></a></p><script>let bodyClx=document.body.classList;let btnDark=document.querySelector('.btn-dark');let sysDark=window.matchMedia('(prefers-color-scheme: dark)');let darkVal=localStorage.getItem('dark');let setDark=(isDark)=>{bodyClx[isDark?'add':'remove']('dark');localStorage.setItem('dark',isDark?'yes':'no');};setDark(darkVal?darkVal==='yes':sysDark.matches);requestAnimationFrame(()=>bodyClx.remove('not-ready'));btnDark.addEventListener('click',()=>setDark(!bodyClx.contains('dark')));sysDark.addEventListener('change',(event)=>setDark(event.matches));</script></header><main class=main><article class=post-single><header class=post-title><p></p><h1>Unleashing the power of frame pointers for profiling pt.2 - Writing a simple profiler</h1></header><section class=post-content><p>In the previous blog about the program execution environment, we introduced the concept of stack unwinding with frame pointers as one of the techniques leveraged for profiling a program.</p><p>In this blog, we&rsquo;ll see practically how we can build a simple sampling-based continuous profiler.</p><p>Because we don&rsquo;t require the application to be instrumented, we can use the Linux kernel instrumentation, and thanks to eBPF we&rsquo;re able to dynamically load and attach the profiler program to specific kernel entry points, limiting the overhead by exchanging data with userspace through eBPF maps.</p><p>To summarize the main actors and responsibilities:</p><ul><li>in kernel space: an eBPF sampler program samples with fixed frequency stack traces for a specific process;</li><li>in userspace: a program collects the samples, calculates the statistics, and resolves the subroutine&rsquo;s symbols.</li></ul><h2 id=kernel-space>Kernel space</h2><h3 id=sample-count>Sample count</h3><p>The eBPF program needs to collect a histogram of the number of samples taken for a specific code path. We&rsquo;ll store this data in a <code>BPF_MAP_TYPE_HASH</code> eBPF hash map:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>struct</span> {
	__uint(type, BPF_MAP_TYPE_HASH);
	__type(key, histogram_key_t);
	__type(value, histogram_value_t);
	__uint(max_entries, K_NUM_MAP_ENTRIES);
} histogram SEC(<span style=color:#e6db74>&#34;.maps&#34;</span>);
</code></pre></div><p>The key of this map which represents the single stack trace it&rsquo;s a structure that contains:</p><ul><li>PID;</li><li>kernel stack ID;</li><li>user stack ID:</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> histogram_key {
	u32 pid;
	u32 kernel_stack_id;
	u32 user_stack_id;
} histogram_key_t;
</code></pre></div><p>The value of this map is a structure that contains mainly the sample count.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> histogram_value {
	u64 count;
	<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>exe_path;
} histogram_value_t;
</code></pre></div><blockquote><p>It also contains the program executable path. We&rsquo;ll see later on why.</p></blockquote><h3 id=stack-trace>Stack trace</h3><p>To get the information about the running code path and the stack trace we can use the <code>bpf_get_stackid</code> eBPF helper.</p><p>eBPF helpers are functions that, as you might have guessed, simplify work. The <a href=https://elixir.bootlin.com/linux/v6.8.5/source/kernel/bpf/stackmap.c#L283><code>bpf_get_stackid</code></a> helper collects user and kernel stack frames by walking the user and kernel stacks and returns the stack ID.</p><p>More precisely from the <a href=https://ebpf-docs.dylanreimerink.nl/linux/helper-function/bpf_get_stackid/>eBPF Docs</a>:</p><blockquote><p>Walk a user or a kernel stack and return its <code>id</code>. To achieve this, the helper needs <code>ctx</code>, which is a pointer to the context on which the tracing program is executed, and a pointer to a map of type <code>BPF_MAP_TYPE_STACK_TRACE</code>.</p></blockquote><p>So, one of the most complex works of stack unwinding is abstracted away thanks to this helper.</p><p>For example, we declare the <code>stack_traces</code> map, we prepare the <code>histogram</code> key:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>struct</span> {
    __uint(type, BPF_MAP_TYPE_STACK_TRACE);
    __uint(key_size, <span style=color:#66d9ef>sizeof</span>(u32));
    __uint(value_size, PERF_MAX_STACK_DEPTH <span style=color:#f92672>*</span> <span style=color:#66d9ef>sizeof</span>(u64));
    __uint(max_entries, <span style=color:#ae81ff>10000</span>);
} stack_traces SEC(<span style=color:#e6db74>&#34;.maps&#34;</span>);

SEC(<span style=color:#e6db74>&#34;perf_event&#34;</span>)
<span style=color:#66d9ef>int</span> sample_stack_trace(<span style=color:#66d9ef>struct</span> bpf_perf_event_data<span style=color:#f92672>*</span> ctx)
{
	histogram_key_t key;

	<span style=color:#75715e>// ...
</span><span style=color:#75715e></span>
	<span style=color:#75715e>/* Sample the user and kernel stack traces, and record in the stack_traces structure. */</span>
	key.pid <span style=color:#f92672>=</span> bpf_get_current_pid_tgid() <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>32</span>;
	key.kernel_stack_id <span style=color:#f92672>=</span> bpf_get_stackid(ctx, <span style=color:#f92672>&amp;</span>stack_traces, <span style=color:#ae81ff>0</span>);
	key.user_stack_id <span style=color:#f92672>=</span> bpf_get_stackid(ctx, <span style=color:#f92672>&amp;</span>stack_traces, <span style=color:#ae81ff>0</span> <span style=color:#f92672>|</span> BPF_F_USER_STACK);
	<span style=color:#75715e>// ...
</span><span style=color:#75715e></span>}
</code></pre></div><p>and for the specific stack trace (<code>key</code>) we update the sample count in the <code>histogram</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>SEC(<span style=color:#e6db74>&#34;perf_event&#34;</span>)
<span style=color:#66d9ef>int</span> sample_stack_trace(<span style=color:#66d9ef>struct</span> bpf_perf_event_data<span style=color:#f92672>*</span> ctx)
{
	histogram_key_t key;
	u64 one <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;

	<span style=color:#75715e>// ...
</span><span style=color:#75715e></span>
	<span style=color:#75715e>/* Sample the user and kernel stack traces, and record in the stack_traces structure. */</span>
	<span style=color:#75715e>// ...
</span><span style=color:#75715e></span>
	<span style=color:#75715e>/* Upsert stack trace histogram */</span>
	count <span style=color:#f92672>=</span> (u64<span style=color:#f92672>*</span>)bpf_map_lookup_elem(<span style=color:#f92672>&amp;</span>histogram, <span style=color:#f92672>&amp;</span>key);
	<span style=color:#66d9ef>if</span> (count) {
		(<span style=color:#f92672>*</span>count)<span style=color:#f92672>++</span>;
	} <span style=color:#66d9ef>else</span> {
		bpf_map_update_elem(<span style=color:#f92672>&amp;</span>histogram, <span style=color:#f92672>&amp;</span>key, <span style=color:#f92672>&amp;</span>one, BPF_NOEXIST);
	}

	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><p>Besides the stack trace sample count we need to retrieve the stack trace, which is a list of instruction pointers. Also this information, thanks to the <a href=https://elixir.bootlin.com/linux/v6.8.5/source/include/uapi/linux/bpf.h#L914><code>BPF_MAP_TYPE_STACK_TRACE</code></a> map is abstracted away for us and is available directly to userspace.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>struct</span> {
	__uint(type, BPF_MAP_TYPE_STACK_TRACE);
	__uint(key_size, <span style=color:#66d9ef>sizeof</span>(u32));
	__uint(value_size, PERF_MAX_STACK_DEPTH <span style=color:#f92672>*</span> <span style=color:#66d9ef>sizeof</span>(u64));
	__uint(max_entries, K_NUM_MAP_ENTRIES);
} stack_traces SEC(<span style=color:#e6db74>&#34;.maps&#34;</span>);
</code></pre></div><p>This is mostly the needed work in kernel space, which is pretty simplified thanks to the Linux kernel instrumentation.</p><p>Let&rsquo;s see how we can use this data in userspace.</p><h2 id=userspace>Userspace</h2><p>Besides loading and attaching the eBPF sampler probe, in userspace we collect the stack traces from <code>stack_traces</code> map. This map is accessible by stack IDs, which are available from the <code>histogram</code> map.</p><p>You can see below an example, using <a href=https://github.com/aquasecurity/libbpfgo>libbpfgo</a> APIs:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;encoding/binary&#34;</span>
	<span style=color:#e6db74>&#34;bytes&#34;</span>
	<span style=color:#e6db74>&#34;unsafe&#34;</span>
)

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>HistogramKey</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>Pid</span> <span style=color:#66d9ef>int32</span>

	<span style=color:#75715e>// UserStackId, an index into the stack-traces map.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>UserStackId</span> <span style=color:#66d9ef>uint32</span>

	<span style=color:#75715e>// KernelStackId, an index into the stack-traces map.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>KernelStackId</span> <span style=color:#66d9ef>uint32</span>
}

<span style=color:#75715e>// StackTrace is an array of instruction pointers (IP).
</span><span style=color:#75715e>// 127 is the size of the profile, as for the default PERF_MAX_STACK_DEPTH.
</span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>StackTrace</span> [<span style=color:#ae81ff>127</span>]<span style=color:#66d9ef>uint64</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Run</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#75715e>// ...
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>it</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>histogram</span>.<span style=color:#a6e22e>Iterator</span>(); <span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>Next</span>(); {
		<span style=color:#a6e22e>k</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>Key</span>()

		<span style=color:#75715e>// Get count for the specific sampled stack trace.
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>countB</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>histogram</span>.<span style=color:#a6e22e>GetValue</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>k</span>[<span style=color:#ae81ff>0</span>]))
		<span style=color:#75715e>// ...
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>count</span> <span style=color:#f92672>:=</span> int(<span style=color:#a6e22e>binary</span>.<span style=color:#a6e22e>LittleEndian</span>.<span style=color:#a6e22e>Uint64</span>(<span style=color:#a6e22e>countB</span>))
		
		<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>key</span> <span style=color:#a6e22e>HistogramKey</span>
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>binary</span>.<span style=color:#a6e22e>Read</span>(<span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>NewBuffer</span>(<span style=color:#a6e22e>k</span>), <span style=color:#a6e22e>binary</span>.<span style=color:#a6e22e>LittleEndian</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>key</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#75715e>// ...
</span><span style=color:#75715e></span>		}

		<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>symbols</span> <span style=color:#66d9ef>string</span>
		<span style=color:#66d9ef>if</span> int32(<span style=color:#a6e22e>key</span>.<span style=color:#a6e22e>UserStackId</span>) <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> {
			<span style=color:#a6e22e>trace</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getStackTrace</span>(<span style=color:#a6e22e>stackTraces</span>, <span style=color:#a6e22e>key</span>.<span style=color:#a6e22e>UserStackId</span>)
			<span style=color:#75715e>// ...
</span><span style=color:#75715e></span>		}
		<span style=color:#66d9ef>if</span> int32(<span style=color:#a6e22e>key</span>.<span style=color:#a6e22e>KernelStackId</span>) <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> {
			<span style=color:#a6e22e>trace</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getStackTrace</span>(<span style=color:#a6e22e>stackTraces</span>, <span style=color:#a6e22e>key</span>.<span style=color:#a6e22e>KernelStackId</span>)
			<span style=color:#75715e>// ...
</span><span style=color:#75715e></span>		}
		<span style=color:#75715e>// ...
</span><span style=color:#75715e></span>}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getStackTrace</span>(<span style=color:#a6e22e>stackTraces</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bpf</span>.<span style=color:#a6e22e>BPFMap</span>, <span style=color:#a6e22e>id</span> <span style=color:#66d9ef>uint32</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>StackTrace</span>, <span style=color:#66d9ef>error</span>) {
	<span style=color:#a6e22e>stackB</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>stackTraces</span>.<span style=color:#a6e22e>GetValue</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>id</span>))
	<span style=color:#75715e>// ...
</span><span style=color:#75715e></span>
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>stackTrace</span> <span style=color:#a6e22e>StackTrace</span>
	<span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>binary</span>.<span style=color:#a6e22e>Read</span>(<span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>NewBuffer</span>(<span style=color:#a6e22e>stackB</span>), <span style=color:#a6e22e>binary</span>.<span style=color:#a6e22e>LittleEndian</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>stackTrace</span>)
	<span style=color:#75715e>// ...
</span><span style=color:#75715e></span>
	<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>stackTrace</span>, <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>Once the sampling is completed, we&rsquo;re able to calculate the program&rsquo;s residency fraction for each subroutine, that is, how much a specific subroutine has been run within a time frame:</p><pre><code>residencyFraction = nTraceSamples / nTotalSamples * 100.
</code></pre><p>You find below the simple code:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>calculateStats</span>() (<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>float64</span>, <span style=color:#66d9ef>error</span>) {
	<span style=color:#75715e>// ...
</span><span style=color:#75715e></span>
	<span style=color:#a6e22e>traceSampleCounts</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>0</span>)
	<span style=color:#a6e22e>totalSampleCount</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
	
	<span style=color:#75715e>// Iterate over the stack profile counts histogram map.
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>it</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>histogram</span>.<span style=color:#a6e22e>Iterator</span>(); <span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>Next</span>(); {
		<span style=color:#75715e>// ...
</span><span style=color:#75715e></span>	
		<span style=color:#75715e>// Increment the traceSampleCounts map value for the stack trace symbol string (e.g. &#34;main;subfunc;&#34;)
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>totalSampleCount</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>count</span>
		<span style=color:#a6e22e>traceSampleCounts</span>[<span style=color:#a6e22e>trace</span>] <span style=color:#f92672>+=</span> <span style=color:#a6e22e>count</span>
	}
	
	<span style=color:#a6e22e>stats</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>float64</span>, len(<span style=color:#a6e22e>traceSampleCounts</span>))
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>trace</span>, <span style=color:#a6e22e>count</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>traceSampleCounts</span> {
		<span style=color:#a6e22e>residencyFraction</span> <span style=color:#f92672>:=</span> float64(<span style=color:#a6e22e>count</span>) <span style=color:#f92672>/</span> float64(<span style=color:#a6e22e>totalSampleCount</span>)
		<span style=color:#a6e22e>stats</span>[<span style=color:#a6e22e>trace</span>] = <span style=color:#a6e22e>residencyFraction</span>
	}

	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>stats</span>, <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>Finally, because traces are an array of instruction pointers that are pushed to the stack, we need to translate addresses to symbols.</p><h3 id=symbolization>Symbolization</h3><p>There are different ways to resolve symbols based on the binary format and the way the binary has been compiled.</p><p>Because this is a demonstration and the profiler is simple we&rsquo;ll consider just ELF binaries that are not stripped.</p><p>The ELF structure contains a symbol table in the <code>.symtab</code> section that holds information needed to locate and relocate a program&rsquo;s symbolic definitions and references. With that information, we&rsquo;re able to associate instruction addresses with subroutine names.</p><p>As the user space program is written in Go, we can leverage the <code>debug/elf</code> package from the standard library to access that information.</p><p>The correct symbol for the instruction pointer is the one of which the start and end addresses are minor or equal, and major or equal respectively to the instruction pointer address:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>loadSymbols</span>() ([]<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>error</span>) {
	<span style=color:#a6e22e>file</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>elf</span>.<span style=color:#a6e22e>Open</span>(<span style=color:#a6e22e>pathname</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>err</span>
	}
	
	<span style=color:#75715e>// Read symbols from the .symtab section.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>syms</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>file</span>.<span style=color:#a6e22e>Symbols</span>()
	<span style=color:#75715e>// ...
</span><span style=color:#75715e></span>
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>sym</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>syms</span> {
		<span style=color:#75715e>// The symbol is correct if the trace instruction pointer address
</span><span style=color:#75715e></span>		<span style=color:#75715e>// is within the symbol address range.
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ip</span> <span style=color:#f92672>&gt;=</span> <span style=color:#a6e22e>sym</span>.<span style=color:#a6e22e>Value</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>ip</span> &lt; (<span style=color:#a6e22e>sym</span>.<span style=color:#a6e22e>Value</span><span style=color:#f92672>+</span><span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Size</span>) {
			<span style=color:#a6e22e>sym</span> = <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Name</span>
		}
	}

	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>syms</span>, <span style=color:#66d9ef>nil</span>
}
</code></pre></div><h2 id=program-executable-path>Program executable path</h2><p>To access the ELF binary we need the process&rsquo;s binary pathname. The pathname can be retrieved in kernel space from the <code>task_struct</code>&rsquo;s user space memory mapping descriptor (<a href=https://elixir.bootlin.com/linux/v6.8.5/source/include/linux/sched.h#L748><code>task_struct</code></a>-><a href=https://elixir.bootlin.com/linux/v6.8.5/source/include/linux/mm_types.h#L734><code>mm_struct</code></a>-><a href=https://elixir.bootlin.com/linux/v6.8.5/source/include/linux/mm_types.h#L905><code>exe_file</code></a>-><a href=https://elixir.bootlin.com/linux/v6.8.5/source/include/linux/fs.h#L1016><code>f_path</code></a>) that we can pass through an eBPF map to userspace.</p><p>The userspace program will then access its <code>.symtab</code> ELF section.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>SEC(<span style=color:#e6db74>&#34;perf_event&#34;</span>)
<span style=color:#66d9ef>int</span> sample_stack_trace(<span style=color:#66d9ef>struct</span> bpf_perf_event_data<span style=color:#f92672>*</span> ctx)
{
	<span style=color:#75715e>/* ... */</span>

	<span style=color:#75715e>/* Get current task executable pathname */</span>
	task <span style=color:#f92672>=</span> (<span style=color:#66d9ef>struct</span> task_struct <span style=color:#f92672>*</span>)bpf_get_current_task(); <span style=color:#75715e>/* Current task struct */</span>
	exe_path <span style=color:#f92672>=</span> get_task_exe_pathname(task);

	<span style=color:#75715e>/* ... */</span>
}

<span style=color:#75715e>/*
</span><span style=color:#75715e> * get_task_exe_pathname returns the task exe_file pathname.
</span><span style=color:#75715e> * This does not apply to kernel threads as they share the same memory-mapped address space,
</span><span style=color:#75715e> * as opposed to user address space.
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>static</span> __always_inline <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>get_task_exe_pathname(<span style=color:#66d9ef>struct</span> task_struct <span style=color:#f92672>*</span>task)
{
	<span style=color:#75715e>/*
</span><span style=color:#75715e>	 * Get ref file path from the task&#39;s user space memory mapping descriptor.
</span><span style=color:#75715e>	 * exe_file-&gt;f_path could also be accessed from current task&#39;s binprm struct 
</span><span style=color:#75715e>	 * (ctx-&gt;args[2]-&gt;file-&gt;f_path)
</span><span style=color:#75715e>	 */</span>
	<span style=color:#66d9ef>struct</span> path path <span style=color:#f92672>=</span> BPF_CORE_READ(task, mm, exe_file, f_path);

	buffer_t <span style=color:#f92672>*</span>string_buf <span style=color:#f92672>=</span> get_buffer(<span style=color:#ae81ff>0</span>);
	<span style=color:#66d9ef>if</span> (string_buf <span style=color:#f92672>==</span> NULL) {
		<span style=color:#66d9ef>return</span> NULL;
	}
	<span style=color:#75715e>/* Write path string from path struct to the buffer */</span>
	size_t buf_off <span style=color:#f92672>=</span> get_pathname_from_path(<span style=color:#f92672>&amp;</span>path, string_buf);
	<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span>string_buf<span style=color:#f92672>-&gt;</span>data[buf_off];
}
</code></pre></div><p>To retrieve the pathname from the <a href=https://elixir.bootlin.com/linux/v6.8.5/source/include/linux/path.h#L8><code>path</code></a> struct we need to walk the directory hierarchy until reaching the root directory of the same VFS mount. For the sake of simplicity, we don&rsquo;t go into the details of this part.</p><h2 id=the-ebpf-program-trigger>The eBPF program trigger</h2><p>To run the eBPF program with a fixed frequency the <a href=https://perf.wiki.kernel.org/index.php/Main_Page>Perf</a> subsystem exposes a kernel software event of type CPU clock (<a href=https://elixir.bootlin.com/linux/v6.8.5/source/include/uapi/linux/perf_event.h#L119><code>PERF_COUNT_SW_CPU_CLOCK</code></a>) with user APIs. Luckily, eBPF programs can be attached to those events.</p><p>So, after the program is loaded:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>import</span> (
	<span style=color:#a6e22e>bpf</span> <span style=color:#e6db74>&#34;github.com/aquasecurity/libbpfgo&#34;</span>
	<span style=color:#e6db74>&#34;github.com/pkg/errors&#34;</span>
	<span style=color:#e6db74>&#34;golang.org/x/sys/unix&#34;</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>loadAndAttach</span>(<span style=color:#a6e22e>probe</span> []<span style=color:#66d9ef>byte</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#a6e22e>bpfModule</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bpf</span>.<span style=color:#a6e22e>NewModuleFromBuffer</span>(<span style=color:#a6e22e>probe</span>, <span style=color:#e6db74>&#34;sample_stack_trace&#34;</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>Wrap</span>(<span style=color:#a6e22e>err</span>, <span style=color:#e6db74>&#34;error creating the BPF module object&#34;</span>)
	}
	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>bpfModule</span>.<span style=color:#a6e22e>Close</span>()

	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bpfModule</span>.<span style=color:#a6e22e>BPFLoadObject</span>(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>Wrap</span>(<span style=color:#a6e22e>err</span>, <span style=color:#e6db74>&#34;error loading the BPF program&#34;</span>)
	}

	<span style=color:#a6e22e>prog</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bpfModule</span>.<span style=color:#a6e22e>GetProgram</span>(<span style=color:#e6db74>&#34;sample_stack_trace&#34;</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>Wrap</span>(<span style=color:#a6e22e>err</span>, <span style=color:#e6db74>&#34;error getting the BPF program object&#34;</span>)
	}

	<span style=color:#75715e>// ...
</span><span style=color:#75715e></span>}
</code></pre></div><p>this Perf event can be leveraged to be able to trigger the sampler every x nanoseconds. Because Perf exposes user APIs, the userspace program can prepare the clock software events for all the CPUs and attach the eBPF program to them:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>import</span> (
	<span style=color:#a6e22e>bpf</span> <span style=color:#e6db74>&#34;github.com/aquasecurity/libbpfgo&#34;</span>
	<span style=color:#e6db74>&#34;github.com/pkg/errors&#34;</span>
	<span style=color:#e6db74>&#34;golang.org/x/sys/unix&#34;</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>loadAndAttach</span>(<span style=color:#a6e22e>probe</span> []<span style=color:#66d9ef>byte</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#75715e>// Load the program...
</span><span style=color:#75715e></span>
	<span style=color:#a6e22e>cpus</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>NumCPU</span>()

	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>cpus</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>attr</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>unix</span>.<span style=color:#a6e22e>PerfEventAttr</span>{
			<span style=color:#a6e22e>Type</span>: <span style=color:#a6e22e>unix</span>.<span style=color:#a6e22e>PERF_TYPE_SOFTWARE</span>,		<span style=color:#75715e>// If type is PERF_TYPE_SOFTWARE, we are measuring software events provided by the kernel.
</span><span style=color:#75715e></span>			<span style=color:#a6e22e>Config</span>: <span style=color:#a6e22e>unix</span>.<span style=color:#a6e22e>PERF_COUNT_SW_CPU_CLOCK</span>,	<span style=color:#75715e>// This reports the CPU clock, a high-resolution per-CPU timer.
</span><span style=color:#75715e></span>			
			<span style=color:#75715e>// A &#34;sampling&#34; event is one that generates an overflow notification every N events,
</span><span style=color:#75715e></span>			<span style=color:#75715e>// where N is given by sample_period.
</span><span style=color:#75715e></span>			<span style=color:#75715e>// sample_freq can be used if you wish to use frequency rather than period.
</span><span style=color:#75715e></span>			<span style=color:#75715e>// sample_period and sample_freq are mutually exclusive.
</span><span style=color:#75715e></span>			<span style=color:#75715e>// The kernel will adjust the sampling period to try and achieve the desired rate.
</span><span style=color:#75715e></span>			<span style=color:#a6e22e>Sample</span>: <span style=color:#ae81ff>10</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>1000</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>1000</span>,
		}
		
		<span style=color:#75715e>// Create the perf event file descriptor that corresponds to one event that is measured.
</span><span style=color:#75715e></span>		<span style=color:#75715e>// We&#39;re measuring a clock timer software event just to run the program on a periodic schedule.
</span><span style=color:#75715e></span>		<span style=color:#75715e>// When a specified number of clock samples occur, the kernel will trigger the program.
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>evt</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>unix</span>.<span style=color:#a6e22e>PerfEventOpen</span>(
			<span style=color:#a6e22e>attr</span>,	<span style=color:#75715e>// The attribute set.
</span><span style=color:#75715e></span>			<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,	<span style=color:#75715e>// All the tasks.
</span><span style=color:#75715e></span>			<span style=color:#a6e22e>i</span>,	<span style=color:#75715e>// on the Nth CPU.
</span><span style=color:#75715e></span>			<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,	<span style=color:#75715e>// The group_fd argument allows event groups to be created.
</span><span style=color:#75715e></span>			<span style=color:#ae81ff>0</span>,	<span style=color:#75715e>// The flags.
</span><span style=color:#75715e></span>		)
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>Wrap</span>(<span style=color:#a6e22e>err</span>, <span style=color:#e6db74>&#34;error creating the perf event&#34;</span>)
		}
		<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() {
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>unix</span>.<span style=color:#a6e22e>Close</span>(<span style=color:#a6e22e>evt</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
				<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>Wrap</span>(<span style=color:#a6e22e>err</span>, <span style=color:#e6db74>&#34;failed to close perf event&#34;</span>)
			}
		}()
		
		<span style=color:#75715e>// Attach the BPF program to the sampling perf event.
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>prog</span>.<span style=color:#a6e22e>AttachPerfEvent</span>(<span style=color:#a6e22e>evt</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>Wrap</span>(<span style=color:#a6e22e>err</span>, <span style=color:#e6db74>&#34;error attaching the BPF probe to the sampling perf event&#34;</span>)
		}
	}

	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}
</code></pre></div><blockquote><p>In this example we&rsquo;re using the <a href=https://github.com/aquasecurity/libbpfgo>libbpfgo</a> library.</p></blockquote><h2 id=wrapping-up>Wrapping up</h2><p>The user program loads the eBPF program, attaches it to the Perf event in order to be triggered with a fixed frequency, and samples stack traces. Trace instruction pointers are resolved into symbols and before returning, the statistics about residency fraction are calculated with data stored in the histogram.</p><p>The statistics are finally printed out like below:</p><pre><code>80% main; foo; bar;
20% main; foo; baz;
</code></pre><p>You can see a full working example at <a href=https://github.com/maxgio92/yap>github.com/maxgio92/yap</a>. YAP is a sampling-based, low overhead kernel-assisted profiler.</p><h2 id=next>Next</h2><p>I personally would like to use statistics to build graph structures, like <a href=https://github.com/brendangregg/FlameGraph>flamegraphs</a>.</p><p>Also, I&rsquo;d like to investigate other ways to extend symbolization support for stripped binaries and collect traces when binaries are built without frame pointers.</p><h2 id=thanks>Thanks</h2><p>Thanks for your time, I hope you enjoyed this blog.</p><p>Any form of feedback is more than welcome. Hear from you soon!</p></section><nav class=post-nav><a class=prev href=https://notes.maxgio.me/notes/power-of-frame-pointers-pt1/><span>←</span><span>Unleashing the power of frame pointers for profiling pt.1 - The environment</span></a>
<a class=next href=https://notes.maxgio.me/notes/stack-walking/><span>Walking the stack on x86 CPU</span><span>→</span></a></nav></article></main><footer class=footer><p>&copy; 2024 <a href=https://notes.maxgio.me/>maxgio's notes</a></p><p>Powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>️</p><p><a href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>Paper 5.1</a></p></footer></body></html>