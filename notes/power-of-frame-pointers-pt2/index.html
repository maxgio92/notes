<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Unleashing the power of frame pointers for profiling pt.1 - Writing a simple profiler - maxgio's notes</title><meta name=description content="In the previous blog I introduced the program execution environment and I have introduced the concepts of stack unwinding with frame pointers as one of the techniques leveraged for profiling a program.
In this blog we&rsquo;ll see practically how we can build a simple profiler which leverages frame pointers by sampling stack traces.
In order to limit the overhead a profiler can work with the help of the Linux kernel, and more procisely eBPF allows to run at specific kernel paths programs, which is in our case the sampler, without the need to load modules."><meta name=author content><link rel="preload stylesheet" as=style href=https://notes.maxgio.me/app.min.css><link rel="preload stylesheet" as=style href=https://notes.maxgio.me/an-old-hope.min.css><script defer src=https://notes.maxgio.me/highlight.min.js onload=hljs.initHighlightingOnLoad();></script><link rel=preload as=image href=https://notes.maxgio.me/theme.png><link rel=icon href=https://notes.maxgio.me/favicon.ico><link rel=apple-touch-icon href=https://notes.maxgio.me/apple-touch-icon.png><meta name=generator content="Hugo 0.79.1"><meta property="og:title" content="Unleashing the power of frame pointers for profiling pt.1 - Writing a simple profiler"><meta property="og:description" content="In the previous blog I introduced the program execution environment and I have introduced the concepts of stack unwinding with frame pointers as one of the techniques leveraged for profiling a program.
In this blog we&rsquo;ll see practically how we can build a simple profiler which leverages frame pointers by sampling stack traces.
In order to limit the overhead a profiler can work with the help of the Linux kernel, and more procisely eBPF allows to run at specific kernel paths programs, which is in our case the sampler, without the need to load modules."><meta property="og:type" content="article"><meta property="og:url" content="https://notes.maxgio.me/notes/power-of-frame-pointers-pt2/"><meta itemprop=name content="Unleashing the power of frame pointers for profiling pt.1 - Writing a simple profiler"><meta itemprop=description content="In the previous blog I introduced the program execution environment and I have introduced the concepts of stack unwinding with frame pointers as one of the techniques leveraged for profiling a program.
In this blog we&rsquo;ll see practically how we can build a simple profiler which leverages frame pointers by sampling stack traces.
In order to limit the overhead a profiler can work with the help of the Linux kernel, and more procisely eBPF allows to run at specific kernel paths programs, which is in our case the sampler, without the need to load modules."><meta itemprop=wordCount content="1110"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Unleashing the power of frame pointers for profiling pt.1 - Writing a simple profiler"><meta name=twitter:description content="In the previous blog I introduced the program execution environment and I have introduced the concepts of stack unwinding with frame pointers as one of the techniques leveraged for profiling a program.
In this blog we&rsquo;ll see practically how we can build a simple profiler which leverages frame pointers by sampling stack traces.
In order to limit the overhead a profiler can work with the help of the Linux kernel, and more procisely eBPF allows to run at specific kernel paths programs, which is in our case the sampler, without the need to load modules."></head><body class=not-ready data-menu=false><header class=header><p class=logo><a class=site-name href=https://notes.maxgio.me/>maxgio's notes</a><a class=btn-dark></a></p><script>let bodyClx=document.body.classList;let btnDark=document.querySelector('.btn-dark');let sysDark=window.matchMedia('(prefers-color-scheme: dark)');let darkVal=localStorage.getItem('dark');let setDark=(isDark)=>{bodyClx[isDark?'add':'remove']('dark');localStorage.setItem('dark',isDark?'yes':'no');};setDark(darkVal?darkVal==='yes':sysDark.matches);requestAnimationFrame(()=>bodyClx.remove('not-ready'));btnDark.addEventListener('click',()=>setDark(!bodyClx.contains('dark')));sysDark.addEventListener('change',(event)=>setDark(event.matches));</script></header><main class=main><article class=post-single><header class=post-title><p></p><h1>Unleashing the power of frame pointers for profiling pt.1 - Writing a simple profiler</h1></header><section class=post-content><p>In the previous blog I introduced the program execution environment and I have introduced the concepts of stack unwinding with frame pointers as one of the techniques leveraged for profiling a program.</p><p>In this blog we&rsquo;ll see practically how we can build a simple profiler which leverages frame pointers by sampling stack traces.</p><p>In order to limit the overhead a profiler can work with the help of the Linux kernel, and more procisely eBPF allows to run at specific kernel paths programs, which is in our case the sampler, without the need to load modules.
This way the analysed program doesn&rsquo;t need to be instrumented.</p><p>The sampler needs to collect stack traces with a fixed frequency. With the samples in user space calculate the statistics.</p><p>To summarize:</p><ul><li>kernel space: sample stack traces for a specific process with a fixed frequency;</li><li>user space: collect samples, calculate the statistics and resolve subroutine symbols.</li></ul><h2 id=kernel-space>Kernel space</h2><p>In the previous blog I introduced the program execution environment and I have introduced the concepts of stack unwinding with frame pointers as one of the techniques leveraged for profiling a program.</p><p>In this blog we&rsquo;ll see practically how we can build a simple profiler which leverages frame pointers by sampling stack traces.</p><p>In order to limit the overhead a profiler can work with the help of the Linux kernel, and more procisely eBPF allows to run at specific kernel paths programs, which is in our case the sampler, without the need to load modules.
This way the analysed program doesn&rsquo;t need to be instrumented.</p><p>The sampler needs to collect stack traces with a fixed frequency. With the samples in user space calculate the statistics.</p><p>To summarize:</p><ul><li>kernel space: sample stack traces for a specific process with a fixed frequency;</li><li>user space: collect samples, calculate the statistics and resolve subroutine symbols.</li></ul><h2 id=kernel-space-1>Kernel space</h2><p>To run the program with a fixed frequency the perf subsystem provides us a clock event and luckily eBPF programs can be attached to perf events.</p><p>So we&rsquo;ll leverage a software CPU clock Perf event just to be able to run the probe every x nanoseconds.</p><p>eBPF helpers are functions that, as you might have guessed, simplify work. The bpf_get_stackid helper returns the stack id of the program that is currently running, at the moment of the eBPF program execution in the very process' context.</p><p>eBPF maps are ways to exchange data, often useful with programs running in user space. There are differnt type of maps and one of them is the BPF_MAP_TYPE_STACK_TRACE that we can access directly in user space to to retrieve the sampled stack&rsquo;s trace, by passing the sampled stack ID.</p><p>This is mostly the needed work in kernel space, which is pretty simple, thanks to the available kernel instrumentation.</p><h2 id=user-space>User space</h2><p>In user space we&rsquo;re able then to access:</p><ul><li>the sampled stack IDs</li><li>the stack traces (keyed by their stack IDs)</li></ul><p>We access the histogram of the sampled stacks that contains the their IDs, to collect the traces.
Once the sampling completes, we&rsquo;re able to provide the information of how much a specific stack trace (function) has been run within the profile time&rsquo;s frame, by calculating:</p><p>stackRunPercentage = nStackSamples / nTotalSamples * 100.</p><p>Finally, because traces are basically array of the pushed instruction pointers, we need to translate IPs to symbols.</p><h3 id=symbolization>Symbolization</h3><p>There are different ways to resolve symbols based on the binary format and the way the binary has been compiled.</p><p>Because this is a demonstration and the profiler is simple we&rsquo;ll consider just ELF binaries that are not stripped.</p><p>The ELF structure contains a symbol table that holds information needed to locate and relocate a program&rsquo;s symbolic definitions and references. With that information we&rsquo;re able to, if this table is not missing as the case of stripped binaries, associate instruction addresses with subroutine names.</p><p>As the user space program is written in Go, we can leverage the standard library to access that information with:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>elf</span>.<span style=color:#a6e22e>ETC</span> <span style=color:#a6e22e>ETC</span> <span style=color:#a6e22e>ETC</span>
</code></pre></div><p>The program loads the eBPF program, attaches it to the perf event created, reads stack IDs with which accesses stack traces. With traces' instruction pointers it resolves symbols and on exit, it calculates the statistics as exmplained before. For example:</p><pre><code>80% main; foo; bar;
20% main; foo; baz;
</code></pre><h2 id=thanks>Thanks</h2><p>To run the program with a fixed frequency the perf subsystem provides us a clock event and luckily eBPF programs can be attached to perf events.</p><p>So we&rsquo;ll leverage a software CPU clock Perf event just to be able to run the probe every x nanoseconds.</p><p>eBPF helpers are functions that, as you might have guessed, simplify work. The bpf_get_stackid helper returns the stack id of the program that is currently running, at the moment of the eBPF program execution in the very process' context.</p><p>eBPF maps are ways to exchange data, often useful with programs running in user space. There are differnt type of maps and one of them is the BPF_MAP_TYPE_STACK_TRACE that we can access directly in user space to to retrieve the sampled stack&rsquo;s trace, by passing the sampled stack ID.</p><p>This is mostly the needed work in kernel space, which is pretty simple, thanks to the available kernel instrumentation.</p><h2 id=user-space-1>User space</h2><p>In user space we&rsquo;re able then to access:</p><ul><li>the sampled stack IDs</li><li>the stack traces (keyed by their stack IDs)</li></ul><p>We access the histogram of the sampled stacks that contains the their IDs, to collect the traces.
Once the sampling completes, we&rsquo;re able to provide the information of how much a specific stack trace (function) has been run within the profile time&rsquo;s frame, by calculating:</p><p>stackRunPercentage = nStackSamples / nTotalSamples * 100.</p><p>Finally, because traces are basically array of the pushed instruction pointers, we need to translate IPs to symbols.</p><h3 id=symbolization-1>Symbolization</h3><p>There are different ways to resolve symbols based on the binary format and the way the binary has been compiled.</p><p>Because this is a demonstration and the profiler is simple we&rsquo;ll consider just ELF binaries that are not stripped.</p><p>The ELF structure contains a symbol table that holds information needed to locate and relocate a program&rsquo;s symbolic definitions and references. With that information we&rsquo;re able to, if this table is not missing as the case of stripped binaries, associate instruction addresses with subroutine names.</p><p>As the user space program is written in Go, we can leverage the standard library to access that information with:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>elf</span>.<span style=color:#a6e22e>ETC</span> <span style=color:#a6e22e>ETC</span> <span style=color:#a6e22e>ETC</span>
</code></pre></div><p>The program loads the eBPF program, attaches it to the perf event created, reads stack IDs with which accesses stack traces. With traces' instruction pointers it resolves symbols and on exit, it calculates the statistics as exmplained before. For example:</p><pre><code>80% main; foo; bar;
20% main; foo; baz;
</code></pre><h2 id=thanks-1>Thanks</h2></section><nav class=post-nav><a class=prev href=https://notes.maxgio.me/notes/program-execution-environment/><span>←</span><span>Unleashing the power of frame pointers for profiling pt.1 - The environment</span></a>
<a class=next href=https://notes.maxgio.me/notes/stack-walking/><span>Walking the stack on x86 CPU</span><span>→</span></a></nav></article></main><footer class=footer><p>&copy; 2024 <a href=https://notes.maxgio.me/>maxgio's notes</a></p><p>Powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>️</p><p><a href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>Paper 5.1</a></p></footer></body></html>