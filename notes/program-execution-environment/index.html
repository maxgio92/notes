<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>The program execution environment - maxgio's notes</title><meta name=description content="The program counter (PC), the stack pointer (SP), and the base pointer (BP) processor registers The program counter (PC)/instruction pointer (IP) is a register that points to code, that is, the instruction that will be executed next. It always points to somewhere in the code. The stack pointer (and base pointer) points to the data: the stack contains data. Considering that the stack grows whenever you add anything new to your stack, including new variables, the stack pointer is the lowest position in the stack (the stack grows from the highest address to the lowest address): so if you declare a new variable of 4 bytes, the stack pointer will be increased by 4 bytes too."><meta name=author content><link rel="preload stylesheet" as=style href=https://notes.maxgio.me/app.min.css><link rel="preload stylesheet" as=style href=https://notes.maxgio.me/an-old-hope.min.css><script defer src=https://notes.maxgio.me/highlight.min.js onload=hljs.initHighlightingOnLoad();></script><link rel=preload as=image href=https://notes.maxgio.me/theme.png><link rel=icon href=https://notes.maxgio.me/favicon.ico><link rel=apple-touch-icon href=https://notes.maxgio.me/apple-touch-icon.png><meta name=generator content="Hugo 0.79.1"><meta property="og:title" content="The program execution environment"><meta property="og:description" content="The program counter (PC), the stack pointer (SP), and the base pointer (BP) processor registers The program counter (PC)/instruction pointer (IP) is a register that points to code, that is, the instruction that will be executed next. It always points to somewhere in the code. The stack pointer (and base pointer) points to the data: the stack contains data. Considering that the stack grows whenever you add anything new to your stack, including new variables, the stack pointer is the lowest position in the stack (the stack grows from the highest address to the lowest address): so if you declare a new variable of 4 bytes, the stack pointer will be increased by 4 bytes too."><meta property="og:type" content="article"><meta property="og:url" content="https://notes.maxgio.me/notes/program-execution-environment/"><meta itemprop=name content="The program execution environment"><meta itemprop=description content="The program counter (PC), the stack pointer (SP), and the base pointer (BP) processor registers The program counter (PC)/instruction pointer (IP) is a register that points to code, that is, the instruction that will be executed next. It always points to somewhere in the code. The stack pointer (and base pointer) points to the data: the stack contains data. Considering that the stack grows whenever you add anything new to your stack, including new variables, the stack pointer is the lowest position in the stack (the stack grows from the highest address to the lowest address): so if you declare a new variable of 4 bytes, the stack pointer will be increased by 4 bytes too."><meta itemprop=wordCount content="1126"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="The program execution environment"><meta name=twitter:description content="The program counter (PC), the stack pointer (SP), and the base pointer (BP) processor registers The program counter (PC)/instruction pointer (IP) is a register that points to code, that is, the instruction that will be executed next. It always points to somewhere in the code. The stack pointer (and base pointer) points to the data: the stack contains data. Considering that the stack grows whenever you add anything new to your stack, including new variables, the stack pointer is the lowest position in the stack (the stack grows from the highest address to the lowest address): so if you declare a new variable of 4 bytes, the stack pointer will be increased by 4 bytes too."></head><body class=not-ready data-menu=false><header class=header><p class=logo><a class=site-name href=https://notes.maxgio.me/>maxgio's notes</a><a class=btn-dark></a></p><script>let bodyClx=document.body.classList;let btnDark=document.querySelector('.btn-dark');let sysDark=window.matchMedia('(prefers-color-scheme: dark)');let darkVal=localStorage.getItem('dark');let setDark=(isDark)=>{bodyClx[isDark?'add':'remove']('dark');localStorage.setItem('dark',isDark?'yes':'no');};setDark(darkVal?darkVal==='yes':sysDark.matches);requestAnimationFrame(()=>bodyClx.remove('not-ready'));btnDark.addEventListener('click',()=>setDark(!bodyClx.contains('dark')));sysDark.addEventListener('change',(event)=>setDark(event.matches));</script></header><main class=main><article class=post-single><header class=post-title><p></p><h1>The program execution environment</h1></header><section class=post-content><h2 id=the-program-counter-pc-the-stack-pointer-sp-and-the-base-pointer-bp-processor-registers>The program counter (PC), the stack pointer (SP), and the base pointer (BP) processor registers</h2><p>The program counter (PC)/instruction pointer (IP) is a register that points to code, that is, the instruction that will be executed next.
It always points to somewhere in the code.
The stack pointer (and base pointer) points to the data: the stack contains data.
Considering that the stack grows whenever you add anything new to your stack, including new variables, the stack pointer is the lowest position in the stack (the stack grows from the highest address to the lowest address): so if you declare a new variable of 4 bytes, the stack pointer will be increased by 4 bytes too.
Specifically, a stack pointer points to the first free and unused address on the stack. You reserve more space on stack by adjusting the stack pointer.</p><p>CALL instruction pushes the current value of PC (next instruction address) and the function arguments into stack, and gives control to the target address (PC is set to the target address of CALL instruction).
So, the just pushed return address is a snapshot of the program counter, available in the stack.
As a result, control is passed to the called address (subroutine) and the return address (the address of the instruction next to CALL) is available.[
RET instruction POPs value from stack (the return address) and puts it in PC.
So, the next instruction is from return.
So, the CALL - RET pair is very useful in the reusability of code.</p><p>Because all of the above points need to be memorized on the stack, the stack size will naturally increase (and thus the stack and base pointers too).</p><p>When a function finishes normally and returns, if the compiler can tell it won’t need to call it again right away, then it is ‘popped’ off the stack and the stack pointer returns to the last position (towards the top) it was before. In the case of a function calling a function, the program counter returns to the next line in the previous stack frame and starts executing from there. The return address was stored in a register or in RAM automatically when the stack frame was created for the function, and in C is not alterable from the source code.</p><p>In a nutshell, the PC is used to memorize the current instruction address:</p><ul><li>After a semicolon, it should increase by 8 bytes (assuming a 64bit instruction set) to point to the next instruction</li><li>If we are in an if() statement but the condition is false, or if we call a function, we&rsquo;ll jump on the 1st instruction of the desired block</li><li>If we are exiting a function, we&rsquo;ll assign the return address to it.</li></ul><p>The memory is already set for the program, it never grows or shrinks, unless more is needed then the OS steps in and gives it some new areas of memory to use.
The heap acquires memory from the bottom of the same region, and “grows up” towards the middle of the same memory region.
Virtual memory and paging, etc, are all kernel stuff. The program uses the one-big linear memory region model that the compiler works out.</p><p><img src=https://raw.githubusercontent.com/maxgio92/notes/68c5220995702493845a3d96cc9d6dc7ce61ec8f/content/notes/memory-regions-allocations.jpg alt=memory-regions-stack-instructions></p><h2 id=what-about-the-frame-pointer>What about the frame pointer?</h2><p>The frame pointer is the base pointer because is set up when a function is called to establish a fixed reference (base) point for accessing local variables and parameters within the function&rsquo;s stack frame. Depending on what ABI you use, parameters are passed either on the stack or via registers. For instance, on i386 System V ABI, parameter 0 is at the base pointer + 8 (i.e. &ldquo;8(%ebp)"). In the x86-64 ABI, parameter 0 is stored in the %rdi register.</p><p>Below the parameters on the stack (remember, the stack grows down) are:</p><ul><li>the return address</li><li>the previous frame pointer</li><li>saved register state</li><li>the local variables of the function.</li></ul><p>Remember: the return address is a snapshot of the program counter, so it points to instructions (code).
The previous frame pointer is a snapshot of the base pointer, so it points to the stack (data).</p><p><img src=https://raw.githubusercontent.com/maxgio92/notes/5ab379b18942d782ac152cc81ad9029ae15d8dd1/content/notes/memory-stack-ip-bp.png alt=stack-return-address-previous-frame-pointer></p><p>Below the local variables are other stack frames resulting from more recent function calls, as well as generic stack space used for computation and temporary storage. The most recent of these is pointed to by the real stack pointer. This is the difference between the stack pointer and the frame/base pointer.</p><p>However, the frame pointer is not always required. Modern compilers can generate code that just uses the stack pointer. At any point in code generation, it can determine where the return address, parameters, and locals are relative to the stack pointer address (either by a constant offset or programmatically).</p><p>Without a frame pointer, though, it is much more difficult for debuggers to determine the stack backtrace. In particular, hardware debuggers that do not have symbolic program information are almost always unable to show the stack.</p><p>Why would you not use a frame pointer? In most architectures it frees up a register, essentially increasing the size of the CPU&rsquo;s fastest and best memory &ndash; its register file.</p><h3 id=clarification-about-the-register-names>Clarification about the register names</h3><p>On 16-bit ISA are usually called SP, BP, and IP.
Instead on 32-bit ESP, EBP, and EIP.
Finally, on 64-bit they&rsquo;re usually called RSP, RBP, and RIP.</p><h2 id=how-the-code-and-the-data-are-loaded-and-organized-in-the-allocated-memory>How the code and the data are loaded and organized in the allocated memory?</h2><blockquote><p>Note: the memory allocation during the fork is only mentioned here.</p></blockquote><p>On program execution (Unix-like fork and exec system call groups) OS allocates memory to later store the program&rsquo;s instructions (code) and data.
On Unix-like operating systems, the exec family of system calls replaces the program executed by a process.
When a process calls exec, all instructions and data - in ELF executable format, they&rsquo;re the text and the data sections - in the process is replaced with the executable of the new program.
The OS then sets the PC to the memory address of the first instruction, which is fetched, decoded, and executed one by one.</p><blockquote><p>As a detail, although all data is replaced, all open file descriptors remain open after calling exec unless explicitly set to close-on-exec.</p></blockquote><p><img src=https://raw.githubusercontent.com/maxgio92/notes/d3bf6f231c330ba746354cc463469245fc9de7bc/content/notes/memory-map-exec.png alt=memory-map-exec></p><p>In particular, on Linux, on execs, the .text and .data ELF sections are loaded by the kernel at the base address.
The main stack is located just below and grows downwards.
Each thread and function call will have its own-stack / stack frame.
This is located below the main stack.
Each stack is separated by a guard page to detect Stack-Overflow.</p><p><img src=https://raw.githubusercontent.com/maxgio92/notes/d3bf6f231c330ba746354cc463469245fc9de7bc/content/notes/memory-map-elf.png alt=memory-map-elf></p><h3 id=elf-structure>ELF structure</h3><p>Digging into the ELF format you can find below the structure of this executable and linkable format:</p><p><img src=https://raw.githubusercontent.com/maxgio92/notes/20f4417f50afb71a79a8712decea1f76ffc16cc9/content/notes/elf-dissection.avif alt=elf-structure></p><p>For more information please refer to the man of file formats and conventions for elf (<code>man 5 elf</code>).</p><h2 id=references>References</h2><ul><li><a href=https://www2.it.uu.se/edu/course/homepage/os/vt19/module-2/process-management/>https://www2.it.uu.se/edu/course/homepage/os/vt19/module-2/process-management/</a></li><li><a href=https://stackoverflow.com/questions/18278803/how-does-elf-file-format-defines-the-stack>https://stackoverflow.com/questions/18278803/how-does-elf-file-format-defines-the-stack</a></li><li><a href=https://stackoverflow.com/questions/21718397/what-are-the-esp-and-the-ebp-registers>https://stackoverflow.com/questions/21718397/what-are-the-esp-and-the-ebp-registers</a></li><li><a href=https://groups.google.com/g/golang-nuts/c/wtw0Swe0CAY>https://groups.google.com/g/golang-nuts/c/wtw0Swe0CAY</a></li><li><a href=https://www.polarsignals.com/blog/posts/2022/01/13/fantastic-symbols-and-where-to-find-them>https://www.polarsignals.com/blog/posts/2022/01/13/fantastic-symbols-and-where-to-find-them</a></li></ul></section><nav class=post-nav><a class=prev href=https://notes.maxgio.me/notes/technicolor-timhub/><span>←</span><span>Technicolor router TIM-branded</span></a>
<a class=next href=https://notes.maxgio.me/notes/tmux/><span>TMux and stuff</span><span>→</span></a></nav></article></main><footer class=footer><p>&copy; 2024 <a href=https://notes.maxgio.me/>maxgio's notes</a></p><p>Powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>️</p><p><a href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>Paper 5.1</a></p></footer></body></html>