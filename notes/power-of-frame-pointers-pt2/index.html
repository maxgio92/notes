<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Unleashing the power of frame pointers for profiling pt.1 - Writing a simple profiler - maxgio's notes</title><meta name=description content="In the previous blog, I introduced the program execution environment and I have introduced the concepts of stack unwinding with frame pointers as one of the techniques leveraged for profiling a program.
In this blog, we&rsquo;ll see practically how we can build a simple profiler that leverages frame pointers by sampling stack traces.
In order to limit the overhead a profiler can work with the help of the Linux kernel, and more precisely eBPF allows it to run at specific kernel paths programs, which is in our case the sampler, without the need to load modules."><meta name=author content><link rel="preload stylesheet" as=style href=https://notes.maxgio.me/app.min.css><link rel="preload stylesheet" as=style href=https://notes.maxgio.me/an-old-hope.min.css><script defer src=https://notes.maxgio.me/highlight.min.js onload=hljs.initHighlightingOnLoad();></script><link rel=preload as=image href=https://notes.maxgio.me/theme.png><link rel=icon href=https://notes.maxgio.me/favicon.ico><link rel=apple-touch-icon href=https://notes.maxgio.me/apple-touch-icon.png><meta name=generator content="Hugo 0.79.1"><meta property="og:title" content="Unleashing the power of frame pointers for profiling pt.1 - Writing a simple profiler"><meta property="og:description" content="In the previous blog, I introduced the program execution environment and I have introduced the concepts of stack unwinding with frame pointers as one of the techniques leveraged for profiling a program.
In this blog, we&rsquo;ll see practically how we can build a simple profiler that leverages frame pointers by sampling stack traces.
In order to limit the overhead a profiler can work with the help of the Linux kernel, and more precisely eBPF allows it to run at specific kernel paths programs, which is in our case the sampler, without the need to load modules."><meta property="og:type" content="article"><meta property="og:url" content="https://notes.maxgio.me/notes/power-of-frame-pointers-pt2/"><meta itemprop=name content="Unleashing the power of frame pointers for profiling pt.1 - Writing a simple profiler"><meta itemprop=description content="In the previous blog, I introduced the program execution environment and I have introduced the concepts of stack unwinding with frame pointers as one of the techniques leveraged for profiling a program.
In this blog, we&rsquo;ll see practically how we can build a simple profiler that leverages frame pointers by sampling stack traces.
In order to limit the overhead a profiler can work with the help of the Linux kernel, and more precisely eBPF allows it to run at specific kernel paths programs, which is in our case the sampler, without the need to load modules."><meta itemprop=wordCount content="1344"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Unleashing the power of frame pointers for profiling pt.1 - Writing a simple profiler"><meta name=twitter:description content="In the previous blog, I introduced the program execution environment and I have introduced the concepts of stack unwinding with frame pointers as one of the techniques leveraged for profiling a program.
In this blog, we&rsquo;ll see practically how we can build a simple profiler that leverages frame pointers by sampling stack traces.
In order to limit the overhead a profiler can work with the help of the Linux kernel, and more precisely eBPF allows it to run at specific kernel paths programs, which is in our case the sampler, without the need to load modules."></head><body class=not-ready data-menu=false><header class=header><p class=logo><a class=site-name href=https://notes.maxgio.me/>maxgio's notes</a><a class=btn-dark></a></p><script>let bodyClx=document.body.classList;let btnDark=document.querySelector('.btn-dark');let sysDark=window.matchMedia('(prefers-color-scheme: dark)');let darkVal=localStorage.getItem('dark');let setDark=(isDark)=>{bodyClx[isDark?'add':'remove']('dark');localStorage.setItem('dark',isDark?'yes':'no');};setDark(darkVal?darkVal==='yes':sysDark.matches);requestAnimationFrame(()=>bodyClx.remove('not-ready'));btnDark.addEventListener('click',()=>setDark(!bodyClx.contains('dark')));sysDark.addEventListener('change',(event)=>setDark(event.matches));</script></header><main class=main><article class=post-single><header class=post-title><p></p><h1>Unleashing the power of frame pointers for profiling pt.1 - Writing a simple profiler</h1></header><section class=post-content><p>In the previous blog, I introduced the program execution environment and I have introduced the concepts of stack unwinding with frame pointers as one of the techniques leveraged for profiling a program.</p><p>In this blog, we&rsquo;ll see practically how we can build a simple profiler that leverages frame pointers by sampling stack traces.</p><p>In order to limit the overhead a profiler can work with the help of the Linux kernel, and more precisely eBPF allows it to run at specific kernel paths programs, which is in our case the sampler, without the need to load modules.
This way the analysed program doesn&rsquo;t need to be instrumented.</p><p>The sampler needs to collect stack traces with a fixed frequency. With the samples in user space calculate the statistics.</p><p>To summarize:</p><ul><li>kernel space: sample stack traces for a specific process with a fixed frequency;</li><li>userspace: collect samples, calculate the statistics, and resolve subroutine symbols.</li></ul><h2 id=kernel-space>Kernel space</h2><p>To run the program with a fixed frequency the perf subsystem provides us a clock software event (<a href=https://elixir.bootlin.com/linux/v6.8.5/source/include/uapi/linux/perf_event.h#L119><code>PERF_COUNT_SW_CPU_CLOCK</code></a>) and luckily eBPF programs can be attached to perf events.</p><p>So we&rsquo;ll leverage a software CPU clock Perf event just to be able to run the probe every x nanoseconds. The userspace loader prepares the Perf event to attach the program to it:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>attr</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>unix</span>.<span style=color:#a6e22e>PerfEventAttr</span>{

  <span style=color:#75715e>// If type is PERF_TYPE_SOFTWARE, we are measuring software events provided by the kernel.
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>Type</span>: <span style=color:#a6e22e>unix</span>.<span style=color:#a6e22e>PERF_TYPE_SOFTWARE</span>,

  <span style=color:#75715e>// This reports the CPU clock, a high-resolution per-CPU timer.
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>Config</span>: <span style=color:#a6e22e>unix</span>.<span style=color:#a6e22e>PERF_COUNT_SW_CPU_CLOCK</span>,

  <span style=color:#75715e>// A &#34;sampling&#34; event is one that generates an overflow notification every N events,
</span><span style=color:#75715e></span>  <span style=color:#75715e>// where N is given by sample_period.
</span><span style=color:#75715e></span>  <span style=color:#75715e>// sample_freq can be used if you wish to use frequency rather than period.
</span><span style=color:#75715e></span>  <span style=color:#75715e>// sample_period and sample_freq are mutually exclusive.
</span><span style=color:#75715e></span>  <span style=color:#75715e>// The kernel will adjust the sampling period to try and achieve the desired rate.
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>Sample</span>: <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>samplingPeriodMillis</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>1000</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>1000</span>,
}

<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>logger</span>.<span style=color:#a6e22e>Debug</span>().<span style=color:#a6e22e>Msg</span>(<span style=color:#e6db74>&#34;opening the sampling software cpu block perf event&#34;</span>)

<span style=color:#75715e>// Create the perf event file descriptor that corresponds to one event that is measured.
</span><span style=color:#75715e>// We&#39;re measuring a clock timer software event just to run the program on a periodic schedule.
</span><span style=color:#75715e>// When a specified number of clock samples occur, the kernel will trigger the program.
</span><span style=color:#75715e></span><span style=color:#a6e22e>evt</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>unix</span>.<span style=color:#a6e22e>PerfEventOpen</span>(
  <span style=color:#75715e>// The attribute set.
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>attr</span>,

  <span style=color:#75715e>// the specified task.
</span><span style=color:#75715e></span>  <span style=color:#75715e>//t.pid,
</span><span style=color:#75715e></span>  <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,

  <span style=color:#75715e>// on the Nth CPU.
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>i</span>,

  <span style=color:#75715e>// The group_fd argument allows event groups to be created. An event group has one event which
</span><span style=color:#75715e></span>  <span style=color:#75715e>// is the group leader. A single event on its own is created with group_fd = -1 and is considered
</span><span style=color:#75715e></span>  <span style=color:#75715e>// to be a group with only 1 member.
</span><span style=color:#75715e></span>  <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,

  <span style=color:#75715e>// The flags.
</span><span style=color:#75715e></span>  <span style=color:#ae81ff>0</span>,
)
<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>Wrap</span>(<span style=color:#a6e22e>err</span>, <span style=color:#e6db74>&#34;error creating the perf event&#34;</span>)
}
<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() {
  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>unix</span>.<span style=color:#a6e22e>Close</span>(<span style=color:#a6e22e>evt</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
    <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>logger</span>.<span style=color:#a6e22e>Fatal</span>().<span style=color:#a6e22e>Err</span>(<span style=color:#a6e22e>err</span>).<span style=color:#a6e22e>Msg</span>(<span style=color:#e6db74>&#34;failed to close perf event&#34;</span>)
  }
}()
</code></pre></div><p>eBPF helpers are functions that, as you might have guessed, simplify work. The <a href=https://elixir.bootlin.com/linux/v6.8.5/source/kernel/bpf/stackmap.c#L283><code>bpf_get_stackid</code></a> helper returns the stack id of the program that is currently running, at the moment of the eBPF program execution in the very process context.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>key.kernel_stack_id <span style=color:#f92672>=</span> bpf_get_stackid(ctx, <span style=color:#f92672>&amp;</span>stack_traces, <span style=color:#ae81ff>0</span> <span style=color:#f92672>|</span> BPF_F_FAST_STACK_CMP);
key.user_stack_id <span style=color:#f92672>=</span> bpf_get_stackid(ctx, <span style=color:#f92672>&amp;</span>stack_traces, <span style=color:#ae81ff>0</span> <span style=color:#f92672>|</span> BPF_F_FAST_STACK_CMP <span style=color:#f92672>|</span> BPF_F_USER_STACK);
</code></pre></div><p>eBPF maps are ways to exchange data, often useful with programs running in user space. There are different types of maps. We use an hash map (<code>BPF_MAP_TYPE_HASH</code>) to exchange the histogram with the stack IDs:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>struct</span> {
	__uint(type, BPF_MAP_TYPE_HASH);
	__type(key, histogram_key_t);		<span style=color:#75715e>/* per-process stack trace key */</span>
	__type(value, u64);			<span style=color:#75715e>/* sample count */</span>
	__uint(max_entries, K_NUM_MAP_ENTRIES);
} histogram SEC(<span style=color:#e6db74>&#34;.maps&#34;</span>);
...
SEC(<span style=color:#e6db74>&#34;perf_event&#34;</span>)
<span style=color:#66d9ef>int</span> sample_stack_trace(<span style=color:#66d9ef>struct</span> bpf_perf_event_data<span style=color:#f92672>*</span> ctx)
{
	...
	u64 one <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
	...
	<span style=color:#75715e>/* Upsert stack trace histogram */</span>
	count <span style=color:#f92672>=</span> (u64<span style=color:#f92672>*</span>)bpf_map_lookup_elem(<span style=color:#f92672>&amp;</span>histogram, <span style=color:#f92672>&amp;</span>key);
	<span style=color:#66d9ef>if</span> (count) {
	  (<span style=color:#f92672>*</span>count)<span style=color:#f92672>++</span>;
	} <span style=color:#66d9ef>else</span> {
	  bpf_map_update_elem(<span style=color:#f92672>&amp;</span>histogram, <span style=color:#f92672>&amp;</span>key, <span style=color:#f92672>&amp;</span>one, BPF_NOEXIST);
	}
}
</code></pre></div><p>and the type <a href=https://elixir.bootlin.com/linux/v6.8.5/source/include/uapi/linux/bpf.h#L914><code>BPF_MAP_TYPE_STACK_TRACE</code></a>:</p><p><strong>eBPF</strong>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>struct</span> {
	__uint(type, BPF_MAP_TYPE_STACK_TRACE);
	__uint(key_size, <span style=color:#66d9ef>sizeof</span>(u32));
	__uint(value_size, PERF_MAX_STACK_DEPTH <span style=color:#f92672>*</span> <span style=color:#66d9ef>sizeof</span>(u64));
	__uint(max_entries, K_NUM_MAP_ENTRIES);
} stack_traces SEC(<span style=color:#e6db74>&#34;.maps&#34;</span>);
</code></pre></div><p>that we can access directly in user space to retrieve the sampled stack&rsquo;s trace, by passing the sampled stack ID:</p><p><strong>Userspace with libbpf-go</strong>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>
<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>HistogramKey</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>Pid</span> <span style=color:#66d9ef>int32</span>

	<span style=color:#75715e>// UserStackId, an index into the stack-traces map.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>UserStackId</span> <span style=color:#66d9ef>uint32</span>

	<span style=color:#75715e>// KernelStackId, an index into the stack-traces map.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>KernelStackId</span> <span style=color:#66d9ef>uint32</span>
}

<span style=color:#75715e>// StackTrace is an array of instruction pointers (IP).
</span><span style=color:#75715e>// 127 is the size of the profile, as for the default PERF_MAX_STACK_DEPTH.
</span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>StackTrace</span> [<span style=color:#ae81ff>127</span>]<span style=color:#66d9ef>uint64</span>

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Profile</span>) <span style=color:#a6e22e>getStackTrace</span>(<span style=color:#a6e22e>stackTraces</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bpf</span>.<span style=color:#a6e22e>BPFMap</span>, <span style=color:#a6e22e>id</span> <span style=color:#66d9ef>uint32</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>StackTrace</span>, <span style=color:#66d9ef>error</span>) {
	<span style=color:#a6e22e>stackBinary</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>stackTraces</span>.<span style=color:#a6e22e>GetValue</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>id</span>))
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>err</span>
	}

	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>stackTrace</span> <span style=color:#a6e22e>StackTrace</span>
	<span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>binary</span>.<span style=color:#a6e22e>Read</span>(<span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>NewBuffer</span>(<span style=color:#a6e22e>stackBinary</span>), <span style=color:#a6e22e>binary</span>.<span style=color:#a6e22e>LittleEndian</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>stackTrace</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>err</span>
	}

	<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>stackTrace</span>, <span style=color:#66d9ef>nil</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Profile</span>) <span style=color:#a6e22e>RunProfile</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>it</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>histogram</span>.<span style=color:#a6e22e>Iterator</span>(); <span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>Next</span>(); {
		<span style=color:#a6e22e>k</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>Key</span>()

		<span style=color:#75715e>// Get count for the specific sampled stack trace.
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>countBinary</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>histogram</span>.<span style=color:#a6e22e>GetValue</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>k</span>[<span style=color:#ae81ff>0</span>]))
		<span style=color:#f92672>...</span>
		<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>key</span> <span style=color:#a6e22e>HistogramKey</span>
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>binary</span>.<span style=color:#a6e22e>Read</span>(<span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>NewBuffer</span>(<span style=color:#a6e22e>k</span>), <span style=color:#a6e22e>binary</span>.<span style=color:#a6e22e>LittleEndian</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>key</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>Wrap</span>(<span style=color:#a6e22e>err</span>, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;error reading the stack profile count key %v&#34;</span>, <span style=color:#a6e22e>k</span>))
		}
		<span style=color:#f92672>...</span>
		<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>symbols</span> <span style=color:#66d9ef>string</span>
		<span style=color:#66d9ef>if</span> int32(<span style=color:#a6e22e>key</span>.<span style=color:#a6e22e>UserStackId</span>) <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> {
			<span style=color:#a6e22e>trace</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>getStackTrace</span>(<span style=color:#a6e22e>stackTraces</span>, <span style=color:#a6e22e>key</span>.<span style=color:#a6e22e>UserStackId</span>)
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
				<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>logger</span>.<span style=color:#a6e22e>Err</span>(<span style=color:#a6e22e>err</span>).<span style=color:#a6e22e>Uint32</span>(<span style=color:#e6db74>&#34;id&#34;</span>, <span style=color:#a6e22e>key</span>.<span style=color:#a6e22e>UserStackId</span>).<span style=color:#a6e22e>Msg</span>(<span style=color:#e6db74>&#34;error getting user stack trace&#34;</span>)
				<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>Wrap</span>(<span style=color:#a6e22e>err</span>, <span style=color:#e6db74>&#34;error getting user stack&#34;</span>)
			}
			<span style=color:#a6e22e>symbols</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>getTraceSymbols</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>pid</span>, <span style=color:#a6e22e>trace</span>, <span style=color:#66d9ef>true</span>)
		}
		<span style=color:#66d9ef>if</span> int32(<span style=color:#a6e22e>key</span>.<span style=color:#a6e22e>KernelStackId</span>) <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> {
			<span style=color:#a6e22e>st</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>getStackTrace</span>(<span style=color:#a6e22e>stackTraces</span>, <span style=color:#a6e22e>key</span>.<span style=color:#a6e22e>KernelStackId</span>)
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
				<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>logger</span>.<span style=color:#a6e22e>Err</span>(<span style=color:#a6e22e>err</span>).<span style=color:#a6e22e>Uint32</span>(<span style=color:#e6db74>&#34;id&#34;</span>, <span style=color:#a6e22e>key</span>.<span style=color:#a6e22e>KernelStackId</span>).<span style=color:#a6e22e>Msg</span>(<span style=color:#e6db74>&#34;error getting kernel stack trace&#34;</span>)
				<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>Wrap</span>(<span style=color:#a6e22e>err</span>, <span style=color:#e6db74>&#34;error getting kernel stack&#34;</span>)
			}
			<span style=color:#a6e22e>symbols</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>getTraceSymbols</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>pid</span>, <span style=color:#a6e22e>st</span>, <span style=color:#66d9ef>false</span>)
		}
}
</code></pre></div><p>This is mostly the needed work in kernel space, which is pretty simple, thanks to the available kernel instrumentation.</p><h2 id=user-space>User space</h2><p>In user space, we&rsquo;re able then to access:</p><ul><li>the sampled stack IDs</li><li>the stack traces (keyed by their stack IDs)</li></ul><p>We access the histogram of the sampled stacks that contain their IDs, to collect the traces.
Once the sampling completes, we&rsquo;re able to calculate the program&rsquo;s residency fraction for each subroutine, that is, how much a specific subroutine has been run within a time frame:</p><pre><code>residencyFraction = nStackSamples / nTotalSamples * 100.
</code></pre><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>fractionTable</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>float64</span>, len(<span style=color:#a6e22e>countTable</span>))
<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>trace</span>, <span style=color:#a6e22e>count</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>countTable</span> {
	<span style=color:#a6e22e>residencyFraction</span> <span style=color:#f92672>:=</span> float64(<span style=color:#a6e22e>count</span>) <span style=color:#f92672>/</span> float64(<span style=color:#a6e22e>sampleCount</span>)
	<span style=color:#a6e22e>fractionTable</span>[<span style=color:#a6e22e>trace</span>] = <span style=color:#a6e22e>residencyFraction</span>
}
</code></pre></div><p>Finally, because traces are an array of pushed instruction pointers, we need to translate IPs to symbols.</p><h3 id=symbolization>Symbolization</h3><p>There are different ways to resolve symbols based on the binary format and the way the binary has been compiled.</p><p>Because this is a demonstration and the profiler is simple we&rsquo;ll consider just ELF binaries that are not stripped.</p><p>The ELF structure contains a symbol table (<code>symtab</code> section) that holds information needed to locate and relocate a program&rsquo;s symbolic definitions and references. With that information, we&rsquo;re able to, if this table is not missing as in the case of stripped binaries, associate instruction addresses with subroutine names.</p><p>As the user space program is written in Go, we can leverage the <code>debug/elf</code> from the standard library to access that information with:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// Open the file
</span><span style=color:#75715e></span><span style=color:#a6e22e>file</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>elf</span>.<span style=color:#a6e22e>Open</span>(<span style=color:#a6e22e>pathname</span>)
<span style=color:#f92672>...</span>
<span style=color:#75715e>// Read symbols from the .symtab section
</span><span style=color:#75715e></span><span style=color:#a6e22e>syms</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>file</span>.<span style=color:#a6e22e>Symbols</span>()
<span style=color:#f92672>...</span>
<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>syms</span> {
  <span style=color:#75715e>// The symbol is correct if the trace instruction pointer address
</span><span style=color:#75715e></span>  <span style=color:#75715e>// is within the symbol address range
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ip</span> <span style=color:#f92672>&gt;=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Value</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>ip</span> &lt; (<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Value</span><span style=color:#f92672>+</span><span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Size</span>) {
    <span style=color:#a6e22e>sym</span> = <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Name</span>
  }
}
</code></pre></div><h2 id=binary-path>Binary path</h2><p>To access the ELF binary we need the process&rsquo;s binary pathname. The path can be accessed from the task&rsquo;s user space memory mapping descriptor (<a href=https://elixir.bootlin.com/linux/v6.8.5/source/include/linux/mm_types.h#L734><code>mm_struct</code></a><code>->exe_file->f_path</code>) that we can pass it through an eBPF map to the user space program.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>struct</span> path path <span style=color:#f92672>=</span> BPF_CORE_READ(task, mm, exe_file, f_path);

buffer_t <span style=color:#f92672>*</span>string_buf <span style=color:#f92672>=</span> get_buffer(<span style=color:#ae81ff>0</span>);
<span style=color:#66d9ef>if</span> (string_buf <span style=color:#f92672>==</span> NULL) {
  <span style=color:#66d9ef>return</span> NULL;
}
<span style=color:#75715e>/* Write path string from path struct to the buffer */</span>
size_t buf_off <span style=color:#f92672>=</span> get_pathname_from_path(<span style=color:#f92672>&amp;</span>path, string_buf);
<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span>string_buf<span style=color:#f92672>-&gt;</span>data[buf_off];
</code></pre></div><p>To retrieve the pathname from the <code>path</code> <code>struct</code> we need to walk the directory hierarchy until reaching the root directory of the same mount.</p><h2 id=wrapping-up>Wrapping up</h2><p>The program loads the eBPF program, attaches it to the perf event created, and reads stack IDs which accesses stack traces. With traces' instruction pointers it resolves symbols and on exit, it calculates the statistics as explained before. For example:</p><pre><code>80% main; foo; bar;
20% main; foo; baz;
</code></pre><h2 id=thanks>Thanks</h2></section><nav class=post-nav><a class=prev href=https://notes.maxgio.me/notes/power-of-frame-pointers-pt1/><span>←</span><span>Unleashing the power of frame pointers for profiling pt.1 - The environment</span></a>
<a class=next href=https://notes.maxgio.me/notes/stack-walking/><span>Walking the stack on x86 CPU</span><span>→</span></a></nav></article></main><footer class=footer><p>&copy; 2024 <a href=https://notes.maxgio.me/>maxgio's notes</a></p><p>Powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>️</p><p><a href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>Paper 5.1</a></p></footer></body></html>