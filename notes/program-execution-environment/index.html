<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Unleashing the power of frame pointers for profilers pt.1 - The environment - maxgio's notes</title><meta name=description content="Profiling the CPU allows us to analyze the program&rsquo;s performance, identify bottlenecks, and optimize its efficiency.
Have you ever wondered what happens behind the scenes when you run a program and how to account for CPU time for the actual program functions? And even more, how to write such a tool to profile the program?
Even though great open-source projects provide continuous profiling with vast support for compiled, JITed, and interpreted, languages, with or without debug info, with or without frame pointers, etc."><meta name=author content><link rel="preload stylesheet" as=style href=https://notes.maxgio.me/app.min.css><link rel="preload stylesheet" as=style href=https://notes.maxgio.me/an-old-hope.min.css><script defer src=https://notes.maxgio.me/highlight.min.js onload=hljs.initHighlightingOnLoad();></script><link rel=preload as=image href=https://notes.maxgio.me/theme.png><link rel=icon href=https://notes.maxgio.me/favicon.ico><link rel=apple-touch-icon href=https://notes.maxgio.me/apple-touch-icon.png><meta name=generator content="Hugo 0.79.1"><meta property="og:title" content="Unleashing the power of frame pointers for profilers pt.1 - The environment"><meta property="og:description" content="Profiling the CPU allows us to analyze the program&rsquo;s performance, identify bottlenecks, and optimize its efficiency.
Have you ever wondered what happens behind the scenes when you run a program and how to account for CPU time for the actual program functions? And even more, how to write such a tool to profile the program?
Even though great open-source projects provide continuous profiling with vast support for compiled, JITed, and interpreted, languages, with or without debug info, with or without frame pointers, etc."><meta property="og:type" content="article"><meta property="og:url" content="https://notes.maxgio.me/notes/program-execution-environment/"><meta itemprop=name content="Unleashing the power of frame pointers for profilers pt.1 - The environment"><meta itemprop=description content="Profiling the CPU allows us to analyze the program&rsquo;s performance, identify bottlenecks, and optimize its efficiency.
Have you ever wondered what happens behind the scenes when you run a program and how to account for CPU time for the actual program functions? And even more, how to write such a tool to profile the program?
Even though great open-source projects provide continuous profiling with vast support for compiled, JITed, and interpreted, languages, with or without debug info, with or without frame pointers, etc."><meta itemprop=wordCount content="3061"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Unleashing the power of frame pointers for profilers pt.1 - The environment"><meta name=twitter:description content="Profiling the CPU allows us to analyze the program&rsquo;s performance, identify bottlenecks, and optimize its efficiency.
Have you ever wondered what happens behind the scenes when you run a program and how to account for CPU time for the actual program functions? And even more, how to write such a tool to profile the program?
Even though great open-source projects provide continuous profiling with vast support for compiled, JITed, and interpreted, languages, with or without debug info, with or without frame pointers, etc."></head><body class=not-ready data-menu=false><header class=header><p class=logo><a class=site-name href=https://notes.maxgio.me/>maxgio's notes</a><a class=btn-dark></a></p><script>let bodyClx=document.body.classList;let btnDark=document.querySelector('.btn-dark');let sysDark=window.matchMedia('(prefers-color-scheme: dark)');let darkVal=localStorage.getItem('dark');let setDark=(isDark)=>{bodyClx[isDark?'add':'remove']('dark');localStorage.setItem('dark',isDark?'yes':'no');};setDark(darkVal?darkVal==='yes':sysDark.matches);requestAnimationFrame(()=>bodyClx.remove('not-ready'));btnDark.addEventListener('click',()=>setDark(!bodyClx.contains('dark')));sysDark.addEventListener('change',(event)=>setDark(event.matches));</script></header><main class=main><article class=post-single><header class=post-title><p></p><h1>Unleashing the power of frame pointers for profilers pt.1 - The environment</h1></header><section class=post-content><p>Profiling the CPU allows us to analyze the program&rsquo;s performance, identify bottlenecks, and optimize its efficiency.</p><p>Have you ever wondered what happens behind the scenes when you run a program and how to account for CPU time for the actual program functions? And even more, how to write such a tool to profile the program?</p><p>Even though great open-source projects provide continuous profiling with vast support for compiled, JITed, and interpreted, languages, with or without debug info, with or without frame pointers, etc., don&rsquo;t be discouraged!</p><p>Writing your own can be a fantastic learning experience. Building your own profiler offers a unique challenge and the satisfaction of unlocking powerful performance analysis tools.</p><p>This blog series will embark on a journey to give you the basics for writing a program profiler.</p><p>In this first episode, we&rsquo;ll establish the foundation by exploring the program execution environment. We&rsquo;ll dig into how the CPU executes a program and keeps track of the execution flow. Finally, we&rsquo;ll discover how this tracking data is stored and becomes the key to unlocking the profiling primitives.</p><h2 id=introduction>Introduction</h2><p>We know that the CPU executes the programs and that the program&rsquo;s binary instructions are stored in a volatile memory which is the random access memory.</p><p>As RAM locations are byte-addressable the CPU needs a way to keep track of the addresses in order to retrieve the data from it, which is in our case CPU instructions that are then executed.</p><p>The CPU uses small built-in memory areas called registers to hold data retrieved from the main memory. Registers come in two types: general-purpose and special-purpose. Special-purpose registers include pointer registers, which are designed specifically to store pointers, which means, they store the memory address&rsquo;s value.</p><p>There are other types of registers but they&rsquo;re out of scope for this walkthrough.</p><p>The first part will go through the main pointer registers, which are commonly implemented by the predominant architectures (x86, ARM, MIPS, PowerPC as far as I know).
So, please consider that these specifics may differ depending on the architecture.</p><h2 id=the-good-the-bad-and-the-ugly-pointer-registers>The good, the bad and the ugly pointer registers</h2><h3 id=the-program-counter>The program counter</h3><p>The program counter (PC), often also called instruction pointer (IP) in x86 architectures, is a register that points to code, that is, the instruction that will be executed next. The instruction data will be fetched, will be stored in the instruction register (IR), and executed during the instruction cycle.
You can follow a diagram of a simplified instruction cycle in the picture below:</p><p><img src=https://raw.githubusercontent.com/maxgio92/notes/b76dfca9825c61c9d1d02c0eddf0b4619869185d/content/images/cpu-pc-ir-cycle.svg alt=cpu-pc-ir></p><ol><li>The CPU control unit (CU) read the value of the PC</li><li>It sends it to the CPU Memory Unit (MU)</li><li>The MU reads the instruction code from the memory at the address pointed to by the PC</li><li>The MU stores the opcode to the IR</li><li>The MU reads the opcode</li><li>The MU sends the opcode to the CU</li><li>The CU instructs the Register File (RF) to read operands - if available from registers, I&rsquo;m simplifying - from general purpose registers (GPR)</li><li>The RF reads operands from GPRs</li><li>The CU sends them to the Arithmetic Logic Unit (ALU), which calculates and stores the result in its temporary memory</li><li>The CU requests the ALU to perform the arithmetic and logic operations</li><li>The RF reads the result from the ALU</li><li>The RF stores the AL result in GPRs</li></ol><p>For example, considering a <code>CALL</code> instruction, this could be the flow considering the PC, the IR and the mainly involved general purpose registers to store the operands:</p><p><img src=https://raw.githubusercontent.com/maxgio92/notes/4979fc04a3da60187ea4e3175dfa8966abdf0fc6/content/images/cpu-pc-ir-cycle-2.svg alt=cpu-pc-ir-call></p><p>Depending on the instruction set, the PC will be increased instruction by instruction by the instruction size (e.g. 8 bytes on 64 but Instruction Set Architectures).</p><p>In an executable file, the machine code to be executed by the CPU is usually stored in a dedicated section, depending on the executable format. For example, in ELF (Executable and Linkable Format) the machine code is organized in the <code>.text</code> section.</p><h3 id=the-stack-pointer>The stack pointer</h3><p>On the other side, the stack pointer (SP) and base pointer (BP) point to the stack, which contains data about the program being executed.</p><p>While a detailed explanation of the stack is beyond the scope of this blog, here&rsquo;s a basic idea: it&rsquo;s a special area of memory that the CPU uses to manage data related to the program&rsquo;s functions (subroutines) as they are called and executed, pushing it to it in a LIFO method. We&rsquo;ll see later on in more detail.</p><p>Data and code are organized in specific regions inside the process address space. It&rsquo;s constantly updated by the CPU on push and pop operations on the stack. The stack pointer is usually set by the OS during the load to point to the top of the stack memory region.</p><p>As the stack grows whenever the CPU adds new data while executing the program&rsquo;s instructions, the stack pointer decrements and is always at the lowest position in the stack.</p><blockquote><p>Remember: the stack grows from the highest address to the lowest address:</p><p><img src=https://raw.githubusercontent.com/maxgio92/notes/faf4b0c39f4a1e2e84a3bb497729fa5863aed5ed/content/images/mem-stack-code-heap.svg alt=mem-stack-code-heap></p></blockquote><p>So, when a new variable of 4 bytes is declared, the stack pointer will be decreased by 4 bytes too.</p><p>For instance, considering a C function that declare a local variable:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>myFunction</span>() {
  <span style=color:#66d9ef>int</span> localVar <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>; <span style=color:#75715e>// Local variable declaration
</span><span style=color:#75715e></span>  <span style=color:#75715e>// Use localVar here
</span><span style=color:#75715e></span>}
</code></pre></div><p>the simplified resulting machine code could be something like the following:</p><pre><code class=language-assembly data-lang=assembly>; Allocate space for local variables (assuming 4 bytes for integer)
sub  rsp, 4               ; Subtract 4 from stack pointer (SP) to reserve space

; Move value 10 (in binary) to localVar's memory location
mov  dword ptr [rsp], 10  ; Move 10 (dword = 4 bytes) to memory pointed to by SP (stack top)

; ...

; Function cleanup (potential instruction to restore stack space)
add  rsp, 4              ; Add 4 back to stack pointer to deallocate local variable space
</code></pre><p>Even though <code>sub</code> + <code>mov</code> is more explicit, as far as I know <code>push</code> is more concise and combines the update of the SP with the move of the variable value.</p><blockquote><p><strong>Clarification about the register names</strong></p><p>You&rsquo;ll find different names for these pointer registers depending on the architectures. For example for x86:</p><ul><li>On 16-bit architecture are usually called <code>sp</code>, <code>bp</code>, and <code>ip</code>.</li><li>Instead on 32-bit <code>esp</code>, <code>ebp</code>, and <code>eip</code>.</li><li>Finally, on 64-bit they&rsquo;re usually called <code>rsp</code>, <code>rbp</code>, and <code>rip</code>.</li></ul></blockquote><p>Specifically, a stack pointer (SP) points to the first free and unused address on the stack.
It can reserve more space on the stack by adjusting the stack pointer like in the previous code example.</p><p>As a detail, a more concise way could be to use <code>push</code> that combines the decrement of the SP (i.e. by 4 bytes) and the store of the operand (i.e. the integer <code>10</code>) at the new address pointed to by the SP.</p><h3 id=the-base-pointer>The base pointer</h3><p>The base pointer (BP) is set during function calls by copying the current SP. The BP is a snapshot of the SP at the moment of the function call (e.g. when the CPU fetches a <code>call</code> instruction), so that function parameters and local variables are accessed by adding and subtracting, respectively, a constant offset from it.</p><p>Moreover when a new function is called a new space in the stack dedicated to the new function is created and some data, besides the function code like declaration of local variables is pushed.</p><p>This memory space dedicated to these subroutines are the stack frames, so each function will have a stack frame. You can find a simple scheme of stack frames with the main data pushed to the stack in the picture below:</p><p><img src=https://raw.githubusercontent.com/maxgio92/notes/99171626abe0c24cf00a66c480287d4701ec61df/content/images/memory-sp-bp.svg alt=memory-sp-bp></p><p>Please bear in mind that the stack layout can vary based on the ABI calling convention and the architecture.</p><p>We&rsquo;ll now go through the call path and see which data is also pushed to the stack, which is used to keep track of the execution path.</p><h2 id=the-call-path>The call path</h2><p>When a new function is called a new memory space dedicated to the function is pushed to the stack, namely a stack frame. It will contain function-specific data like arguments, local variables, and saved registers if needed.
Moreover, the previous base pointer (BP) is also pushed to the stack.</p><p>While this is usually true, it&rsquo;s not mandatory and it depends on how the binary has been compiled. This mainly depends on the compiler optimization techniques.</p><p>In particular, CALL instruction pushes also the value of the program counter at the moment of the new function call (next instruction address), and gives control to the target address. The program counter is set to the target address of the <code>CALL</code> instruction, which is, the first instruction of the called function.</p><p>In a nutshell: the just pushed return address is a snapshot of the program counter, and the pushed frame pointer is a snapshot of the base pointer, and they&rsquo;re both available in the stack.</p><p>As a result, control is passed to the called subroutine address and the return address, that is the address of the instruction next to <code>CALL</code>, is available.</p><p>The following diagram wrap ups what&rsquo;s been discussed until now:</p><p><img src=https://raw.githubusercontent.com/maxgio92/notes/352907a2c42b9f695d0a97e6cd8d3e95977d024d/content/images/pc-sp-bc-stack-code.svg alt=pc-sp-bc-stack-code></p><h2 id=the-return-path>The return path</h2><p>On the return path from the function, <code>RET</code> instruction <code>POP</code>s the return address from the stack and puts it in the program counter register. So, the next instruction is available from that return address.</p><p>Since the program counter register holds the address of the next instruction to be executed, loading the return address into the PC effectively points the program execution to the instruction that follows the function call. This ensures the program resumes execution from the correct location after the function is completed.</p><p><img src=https://raw.githubusercontent.com/maxgio92/notes/14bdde325f646b53ee0b6501f0ba9d3ecbaded4f/content/notes/memory-stack-frames.png alt=stack-frames></p><p>In the case of a function calling a function, the program counter returns to the return address in the previous stack frame and starts executing from there.</p><p>Because all of the above points need to be memorized on the stack, the stack size will naturally increase, and on return decrease. And of course, the same happens to the stack and base pointers. Naturally, the stack is protected by a guard to avoid the stack overflow accessing unexpected area of memory.</p><p>As I&rsquo;m a visual learner, the next section will show how the program&rsquo;s code and data are organized in its process address space. This should give you a clearer picture of their layout within the process&rsquo;s address space.</p><h2 id=the-address-space-regions>The address space regions</h2><p>The process address space is a logical view of memory managed by the operating system, hiding the complexity of managing physical memory.</p><p>While explaining how memory mapping implementations work in operating systems is out of scope here, it&rsquo;s important to say that user processes see one contiguous memory space thanks to the memory mapping features provided by the OS.</p><p>The address space is typically divided into different regions, and the following names are mostly standard between the operating systems:</p><ul><li>Text segment: this is the area where the (machine) code of the program is stored</li><li>Data segment: this region contains typically static variables which are initialized</li><li>BSS (Block Started by Symbol) segment: it contains global and static variables that are not initialized when the program starts.
Because the data would be a block of zeros, the BSS content is omitted in the executable file, saving space. Instead, the program headers allow the loader to know how much space to allocate for the BSS section in virtual memory and it filled it out with zeros. That&rsquo;s why, despite uninitialized data being data, is not placed in the data section.</li><li>Heap: it&rsquo;s a region available for dynamic allocation available to the running process. Programs can request pages from it at runtime (e.g. <code>malloc</code> from the C standard library).</li><li>Stack: we already talked about it.</li></ul><p>The next diagram will show the discussed memory regions starting from the physical perspective to the perspective of the single virtual address space of a program process:</p><p><img src=https://raw.githubusercontent.com/maxgio92/notes/68c5220995702493845a3d96cc9d6dc7ce61ec8f/content/notes/memory-regions-allocations.jpg alt=memory-regions-stack-instructions></p><blockquote><p>Credits for the diagram to <a href=https://yousha.blog.ir/>yousha.blog.ir</a>.</p></blockquote><p>The operating system can enforce protection for each of them, like marking the text segment read-only to prevent modification of the running program&rsquo;s instructions.</p><p>When a program is loaded into memory, the operating system allocates a specific amount of memory for it and dedicates specific regions to static and dynamic allocation. The static allocation includes the allocation for the program&rsquo;s instructions and the stack.</p><p>Dynamic allocations can be handled by the stack or the heap. The heap usually acquires memory from the bottom of the same region and grows upwards towards the middle of the same memory region.</p><p><img src=https://raw.githubusercontent.com/maxgio92/notes/b64ccd53d5c3a07969dd70f1a5a394c04edd8c35/content/images/memory-regions.svg alt=memory-regions></p><h2 id=program-loading-in-unix-like-oses>Program loading in Unix-like OSes</h2><p>On program execution (Unix-like <code>fork</code> and <code>exec</code> system call groups) OS allocates memory to later store the program&rsquo;s instructions (in the text segment) and data (in the stack).
The <code>exec</code> family of system calls replaces the program executed by a process.
When a process calls <code>exec</code>, all sections are replaced, including the <code>.text</code> section, and the data in the process are replaced with the executable of the new program.</p><p>In particular, the loader parses the executable file, decides which is the base address, allocates memory for the program segments based on the base address, loads the segments in memory, and prepares the execution environment.</p><p>Once the loader completes its tasks, it signals the kernel the program is ready. The kernel sets the process context and the PC to the first instruction in the <code>.text</code> section, which is fetched, decoded, and executed by the CPU.</p><p><img src=https://raw.githubusercontent.com/maxgio92/notes/d3bf6f231c330ba746354cc463469245fc9de7bc/content/notes/memory-map-exec.png alt=memory-map-exec></p><blockquote><p>I haven&rsquo;t managed yet to find where the information about how to set up the stack at exec time from an ELF file is stored in the ELF structure. If you do, feel free to share it!</p></blockquote><p>Moreover, as a detail, although all data is replaced, all open file descriptors remain open after calling exec unless explicitly set to close-on-exec.</p><p>In particular, on Linux, on execs, the <code>.text</code> and <code>.data</code> ELF sections are loaded by the kernel at the base address. The main stack is located just below and grows downwards.</p><p>If you want to go deeper on the Linux <code>exec</code> path, I recommend <a href=https://github.com/0xAX/linux-insides/blob/f7c6b82a5c02309f066686dde697f4985645b3de/SysCall/linux-syscall-4.md#execve-system-call>this chapter</a> from the <a href=https://0xax.gitbooks.io/linux-insides/content/index.html>Linux insides</a> book.</p><p>Now let&rsquo;s get back to the main characters of this blog, which are the pointer register. We mentioned that the base pointer is also called the frame pointer, indeed it points to a single stack frame. But, let&rsquo;s see how they&rsquo;re vital for CPU profiling.</p><h2 id=frame-pointer-and-the-stack-walking>Frame pointer and the stack walking</h2><p>I&rsquo;ve read more often the name <em>frame pointer</em> than <em>base pointer</em>, but actually the frame pointer <em>is</em> the base pointer.</p><p>As already discussed, the name base pointer comes to the fact that is set up when a function is called and is pushed to the new stack frame, to establish a fixed reference (base) to access local variables and parameters within the function&rsquo;s stack frame.</p><p>What is pushed to the stack are also the parameters, but depending on the ABI, they can be passed either on the stack or via registers. For instance:</p><ul><li>x86-64 System V ABI: in the general purpose registers <code>rdi</code>, <code>rsi</code>, <code>rdx</code>, <code>rcx</code>, <code>r8</code>, and <code>r9</code> for the first six parameters. On the stack from the seventh parameter onward.</li><li>i386 System V ABI: in the general purpose registers <code>eax</code>, <code>ecx</code>, <code>edx</code>, and <code>ebx</code> for the first four parameters. On the stack from the fifth parameter onward.</li></ul><p>In general, the data that is commonly stored on the stack is:</p><ul><li>the return address</li><li>the previous frame pointer</li><li>saved register state</li><li>the local variables of the function.</li></ul><p><img src=https://github.com/maxgio92/notes/raw/95038de4ae46e0b980cfbdbae35817132b3afffd/content/images/memory-sp-bp-3.svg alt=memory-sp-bp-3></p><blockquote><p>Remember: the return address is a snapshot of the program counter, so it points to instructions (code).
The previous frame pointer is a snapshot of the base pointer, so it points to the stack (data).</p></blockquote><p>Below the local variables are other stack frames resulting from more recent function calls, as well as generic stack space used for computation and temporary storage. The most recent of these is pointed to by the stack pointer. This is the difference between the stack pointer and the frame/base pointer.</p><p>However, the frame pointer is not always required. Compiler optimization technique can generate code that just uses the stack pointer.</p><p>Frame pointer elimination (FPE) is an optimization that removes the need for a frame pointer under certain conditions, mainly to reduce the space allocated for the stack and to optimize performance because pushing and popping the frame pointer takes time during the function call. The compiler analyzes the function&rsquo;s code to see if it relies on the frame pointer for example to access local variables, or if the function does not call any other function. At any point in code generation, it can determine where the return address, parameters, and locals are relative to the stack pointer address (either by a constant offset or programmatically).</p><p>Frame pointer omission (FPO) is instead an optimization that simply instructs the compiler to not generate instructions to push and pop the frame pointer at all during function calls and returns.</p><blockquote><p>If you&rsquo;re interested in the impacts of libraries compiled and distributed with this optimization I recommend the following Brendan Gregg&rsquo;s great article: <a href=https://www.brendangregg.com/blog/2024-03-17/the-return-of-the-frame-pointers.html>The Return of the Frame Pointers</a>.</p></blockquote><p>Because the frame pointer is pushed on function call to the stack frame just created for the newly called function, and its value is the value of the stack pointer at the moment of the <code>CALL</code>, it points to the previous stack frame. One technique to talk the stack is to follow the linked list of the saved frame pointers, beginning with the value hold by the frame (base) pointer register.</p><p>Thanks to the <em>stack walking</em> technique that leverages the saved frame pointers, stack traces can be built. As a <code>RET</code> (function returns) pops a stack frame out of the stack, when consequent <code>RET</code>s reach the top of the stack, which is the stack frame of the main function, a stack trace is complete. The same goes on and on with subsequent chains of call-returns that reach the top of the stack.</p><p>You can see it in the following picture a simplified scheme of the linked list of frame pointers:</p><p><img src=https://raw.githubusercontent.com/maxgio92/notes/5eeff1703e85c00799e7af0117a3898918d7a438/content/notes/stack-walking.avif alt=stack-walking></p><p>This technique is particularly useful for profilers and debuggers. The following is a basic example of what a profiler could retrieve, leveraging frame pointers:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ ./my-profiler run --pid <span style=color:#ae81ff>12345</span>
 2.6%     main.main;runtime.main;runtime.goexit;
65.3%     main.foo;runtime.main;runtime.goexit;
32.1%     main.bar;runtime.main;runtime.goexit;
</code></pre></div><p>And this comes to the next episode of this series, which will dive into how to program stack walking and how to account for each function CPU time!</p><p>I hope this has been interesting to you. Any feedback is more than appreciated.</p><p>See you in the next episode!</p><h2 id=references>References</h2><ul><li><a href=https://www2.it.uu.se/edu/course/homepage/os/vt19/module-2/process-management/>https://www2.it.uu.se/edu/course/homepage/os/vt19/module-2/process-management/</a></li><li><a href=https://stackoverflow.com/questions/18278803/how-does-elf-file-format-defines-the-stack>https://stackoverflow.com/questions/18278803/how-does-elf-file-format-defines-the-stack</a></li><li><a href=https://stackoverflow.com/questions/21718397/what-are-the-esp-and-the-ebp-registers>https://stackoverflow.com/questions/21718397/what-are-the-esp-and-the-ebp-registers</a></li><li><a href=https://groups.google.com/g/golang-nuts/c/wtw0Swe0CAY>https://groups.google.com/g/golang-nuts/c/wtw0Swe0CAY</a></li><li><a href=https://www.polarsignals.com/blog/posts/2022/01/13/fantastic-symbols-and-where-to-find-them>https://www.polarsignals.com/blog/posts/2022/01/13/fantastic-symbols-and-where-to-find-them</a></li><li><a href=https://0xax.gitbooks.io/linux-insides/content/index.html>https://0xax.gitbooks.io/linux-insides/content/index.html</a></li><li><a href=https://blog.px.dev/cpu-profiling/>https://blog.px.dev/cpu-profiling/</a></li></ul></section><nav class=post-nav><a class=prev href=https://notes.maxgio.me/notes/kubernetes-controllers/><span>←</span><span>Understanding Kubernetes controllers</span></a>
<a class=next href=https://notes.maxgio.me/notes/stack-walking/><span>Walking the stack on x86 CPU</span><span>→</span></a></nav></article></main><footer class=footer><p>&copy; 2024 <a href=https://notes.maxgio.me/>maxgio's notes</a></p><p>Powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>️</p><p><a href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>Paper 5.1</a></p></footer></body></html>