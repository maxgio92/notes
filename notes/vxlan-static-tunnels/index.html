<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Static VXLAN tunnels - maxgio's notes</title><meta name=description content="In VXLAN-based networks, there are a range of complexities and challenges in determining the destination virtual tunnel endpoints (VTEPs) for any given VXLAN. At scale, solutions such EVPN try to address these complexities, however, they also have their own complexities.
Static VXLAN tunnels serve to connect two VTEPs in a given environment. Static VXLAN tunnels are the simplest deployment mechanism for small scale environments and are interoperable with other vendors that adhere to VXLAN standards."><meta name=author content><link rel="preload stylesheet" as=style href=https://notes.maxgio.me/app.min.css><link rel="preload stylesheet" as=style href=https://notes.maxgio.me/an-old-hope.min.css><script defer src=https://notes.maxgio.me/highlight.min.js onload=hljs.initHighlightingOnLoad();></script><link rel=preload as=image href=https://notes.maxgio.me/theme.png><link rel=icon href=https://notes.maxgio.me/favicon.ico><link rel=apple-touch-icon href=https://notes.maxgio.me/apple-touch-icon.png><meta name=generator content="Hugo 0.79.1"><meta property="og:title" content="Static VXLAN tunnels"><meta property="og:description" content="In VXLAN-based networks, there are a range of complexities and challenges in determining the destination virtual tunnel endpoints (VTEPs) for any given VXLAN. At scale, solutions such EVPN try to address these complexities, however, they also have their own complexities.
Static VXLAN tunnels serve to connect two VTEPs in a given environment. Static VXLAN tunnels are the simplest deployment mechanism for small scale environments and are interoperable with other vendors that adhere to VXLAN standards."><meta property="og:type" content="article"><meta property="og:url" content="https://notes.maxgio.me/notes/vxlan-static-tunnels/"><meta itemprop=name content="Static VXLAN tunnels"><meta itemprop=description content="In VXLAN-based networks, there are a range of complexities and challenges in determining the destination virtual tunnel endpoints (VTEPs) for any given VXLAN. At scale, solutions such EVPN try to address these complexities, however, they also have their own complexities.
Static VXLAN tunnels serve to connect two VTEPs in a given environment. Static VXLAN tunnels are the simplest deployment mechanism for small scale environments and are interoperable with other vendors that adhere to VXLAN standards."><meta itemprop=wordCount content="808"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Static VXLAN tunnels"><meta name=twitter:description content="In VXLAN-based networks, there are a range of complexities and challenges in determining the destination virtual tunnel endpoints (VTEPs) for any given VXLAN. At scale, solutions such EVPN try to address these complexities, however, they also have their own complexities.
Static VXLAN tunnels serve to connect two VTEPs in a given environment. Static VXLAN tunnels are the simplest deployment mechanism for small scale environments and are interoperable with other vendors that adhere to VXLAN standards."></head><body class=not-ready data-menu=false><header class=header><p class=logo><a class=site-name href=https://notes.maxgio.me/>maxgio's notes</a><a class=btn-dark></a></p><script>let bodyClx=document.body.classList;let btnDark=document.querySelector('.btn-dark');let sysDark=window.matchMedia('(prefers-color-scheme: dark)');let darkVal=localStorage.getItem('dark');let setDark=(isDark)=>{bodyClx[isDark?'add':'remove']('dark');localStorage.setItem('dark',isDark?'yes':'no');};setDark(darkVal?darkVal==='yes':sysDark.matches);requestAnimationFrame(()=>bodyClx.remove('not-ready'));btnDark.addEventListener('click',()=>setDark(!bodyClx.contains('dark')));sysDark.addEventListener('change',(event)=>setDark(event.matches));</script></header><main class=main><article class=post-single><header class=post-title><p></p><h1>Static VXLAN tunnels</h1></header><section class=post-content><p>In VXLAN-based networks, there are a range of complexities and challenges in determining the destination virtual tunnel endpoints (VTEPs) for any given VXLAN. At scale, solutions such EVPN try to address these complexities, however, they also have their own complexities.</p><p>Static VXLAN tunnels serve to connect two VTEPs in a given environment.
Static VXLAN tunnels are the simplest deployment mechanism for small scale environments and are interoperable with other vendors that adhere to VXLAN standards. Because you simply map which VTEPs are in a particular VNI, you can avoid the tedious process of defining connections to every VLAN on every other VTEP on every other rack.</p><p>Static Virtual Extensible LAN (VXLAN), also known as unicast VXLAN, enables you to statically configure source and destination virtual tunnel endpoints (VTEPs) for a particular traffic flow (VNI).</p><p>A source VTEP encapsulates and a destination VTEP de-encapsulates Layer 2 packets with a VXLAN header, thereby tunneling the packets through an underlying Layer 3 IP network.</p><h2 id=benefits-of-static-vxlan>Benefits of Static VXLAN</h2><p>Instead of using an Ethernet VPN (EVPN) control plane to learn the MAC addresses of hosts, static VXLAN uses a flooding-and-learning technique in the VXLAN data plane.</p><p>Therefore, using static VXLAN reduces complexity in the control plane.
Static VXLAN provides the benefits of VXLAN and is relatively easy to design and configure.</p><h2 id=how-static-vxlan-works>How Static VXLAN Works</h2><p>To enable static VXLAN on a device that functions as a VTEP, you must configure:</p><ul><li>A list that includes one or more remote VTEPs with which the local VTEP can form a VXLAN tunnel.</li><li>Ingress node replication.</li><li>The VTEP’s loopback interface (lo0):<ul><li>Configure an anycast IP address as the primary interface.</li><li>Specify this interface as the source interface for a VXLAN tunnel.</li></ul></li></ul><p>When a VTEP receives a broadcast, unknown unicast, or multicast (BUM) packet, the VTEP uses ingress node replication to replicate and flood the packet to the statically defined remote VTEPs on your list.</p><p>The remote VTEPs in turn flood the packet to the hosts in each VXLAN of which the VTEPs are aware.</p><p>The VTEPs learn the MAC addresses of remote hosts from the VTEPs on the remote VTEP list and the MAC addresses of local hosts from the local access interfaces.</p><p>Upon learning a MAC address of a host, the MAC address is then added to the Ethernet switching table.</p><p>In this environment, static VXLAN serves two purposes:</p><ul><li>To learn the MAC addresses of hosts in a VXLAN. To accomplish this task, static VXLAN uses the ingress node replication feature to flood broadcast, unknown unicast, and multicast (BUM) packets throughout a VXLAN. The VTEPs learn the MAC addresses of remote hosts from the VTEPs on the remote VTEP list and the MAC addresses of local hosts from the local access interfaces. Upon learning of a host’s MAC address, the MAC address is then added to the Ethernet switching table.</li><li>To encapsulate Layer 2 packets with a VXLAN header and later de-encapsulate the packets, thereby enabling them to be tunneled through an underlying Layer 3 IP network. For this task to be accomplished, on each VTEP, you configure a list of statically defined remote VTEPs with which the local VTEP can form a VXLAN tunnel.</li></ul><h2 id=requirements>Requirements</h2><p>For a basic VXLAN configuration, make sure that:</p><ul><li>The VXLAN has a network identifier (VNI).</li><li>Bridge learning must be enabled on the VNI (bridge learning is disabled by default).</li><li>The VXLAN link and local interfaces are added to the bridge to create the association between the port, VLAN and VXLAN instance.</li><li>Each traditional mode bridge on the switch has only one VXLAN interface.</li></ul><h2 id=configure-static-vxlan-tunnels>Configure Static VXLAN Tunnels</h2><p>To configure static VXLAN tunnels, do the following on each leaf:</p><ul><li>Specify an IP address for the loopback.</li><li>Create a VXLAN interface using the loopback address for the local tunnel IP address.</li><li>Enable bridge learning on the VNI.</li><li>Create the tunnels by configuring the remote IP address to each other leaf switch’s loopback address.</li></ul><p>With <code>iproute2</code> tools you can add a link with of type VXLAN (iproute supports VXLAN):</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#75715e># ip link add &lt;NAME&gt; type vxlan id &lt;VXLAN Network Identifier (VNI)&gt; dev &lt;PHYSICAL DEVICE FOR TUNNEL COMMUNICATION TO THE OTHER VTEP&gt; dstport 0</span>
ip link add vxlan0 type vxlan id <span style=color:#ae81ff>42</span> dev eth0 dstport <span style=color:#ae81ff>0</span>
</code></pre></div><p>Configure the forward (fdb) entry:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#75715e># ridge fdb append to 00:00:00:00:00:00 dev &lt;VXLAN DEVICE NAME&gt; dst &lt;VTEP UNDERLYING NETWORK&#39;S IP&gt;</span>
bridge fdb append to 00:00:00:00:00:00 dev vxlan0 dst 192.168.94.83 
</code></pre></div><p>Assign an IP with CIDR subnet in the VXLAN network subnet, to the local VTEP VXLAN device:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ip address add vxlan0 172.16.0.2/24
</code></pre></div><p>Assuming that the remote VTEP has configured a VXLAN IP 172.16.0.1, you can test the connection, by pinging the remote VTEP VXLAN IP:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ping 172.16.0.1
</code></pre></div><p>And you can now see that the fdb has been populated with the remote VTEP MAC address too:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>f6:df:a6:e6:96:a7 dev vxlan0 dst 192.168.94.83 self
</code></pre></div><hr><p>References:</p><ul><li><a href=https://docs.nvidia.com/networking-ethernet-software/cumulus-linux-44/Layer-2/Ethernet-Bridging-VLANs>https://docs.nvidia.com/networking-ethernet-software/cumulus-linux-44/Layer-2/Ethernet-Bridging-VLANs</a></li><li><a href=https://docs.nvidia.com/networking-ethernet-software/cumulus-linux-43/Network-Virtualization/Static-VXLAN-Tunnels/>https://docs.nvidia.com/networking-ethernet-software/cumulus-linux-43/Network-Virtualization/Static-VXLAN-Tunnels/</a></li><li><a href=https://www.juniper.net/documentation/us/en/software/junos/evpn-vxlan/topics/topic-map/vxlan-static.html>https://www.juniper.net/documentation/us/en/software/junos/evpn-vxlan/topics/topic-map/vxlan-static.html</a></li><li><a href=https://www.redhat.com/sysadmin/kubernetes-pods-communicate-nodes>https://www.redhat.com/sysadmin/kubernetes-pods-communicate-nodes</a></li><li><a href=https://github.com/angelnu/gateway-admision-controller/issues/102>https://github.com/angelnu/gateway-admision-controller/issues/102</a></li><li><a href=https://man7.org/linux/man-pages/man8/bridge.8.html>https://man7.org/linux/man-pages/man8/bridge.8.html</a></li></ul></section><nav class=post-nav><a class=prev href=https://notes.maxgio.me/notes/spit-locks/><span>←</span><span>Spit locks</span></a>
<a class=next href=https://notes.maxgio.me/notes/suricata-homelab/><span>Suricata in a homelab</span><span>→</span></a></nav></article></main><footer class=footer><p>&copy; 2025 <a href=https://notes.maxgio.me/>maxgio's notes</a></p><p>Powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>️</p><p><a href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>Paper 5.1</a></p></footer></body></html>